{"version":3,"file":"AppNode.js","names":["produce","getLoadingScreenType","isNullOrUndefined","LoadingScreenType","makeAppSkeletonElement","makeElementWithErrorText","makeElementWithInfoText","notUndefined","Block","BlockProto","ForwardMsgMetadata","Quiver","ensureError","NO_SCRIPT_RUN_ID","ElementNode","constructor","element","metadata","scriptRunId","activeScriptHash","fragmentId","lazyQuiverElement","lazyVegaLiteChartElement","quiverElement","undefined","type","Error","toReturn","vegaLiteChartElement","proto","arrowVegaLiteChart","modifiedData","data","modifiedDatasets","datasets","length","wrapDatasets","spec","useContainerWidth","vegaLiteTheme","theme","id","selectionMode","formId","getIn","setIn","filterMainScriptElements","mainScriptHash","clearStaleNodes","currentScriptRunId","fragmentIdsThisRun","fragmentIdOfBlock","getElements","elements","Set","add","arrowAddRows","namedDataSet","elementType","newNode","quiverAddRowsHelper","vegaLiteChartAddRowsHelper","hasName","newQuiver","addRows","newDataSetName","name","newDataSetQuiver","draft","existingDataSet","getNamedDataSet","namedDataSets","find","dataset","BlockNode","children","deltaBlock","deltaMsgReceivedAt","isEmpty","path","childIndex","slice","node","newChildren","map","child","filter","includes","elementSet","AppRoot","empty","arguments","isInitialRender","sidebarElements","logo","mainNodes","waitElement","NONE","V1","push","create","main","allowEmpty","sidebar","event","bottom","appLogo","root","appRootWithLogo","applyDelta","delta","deltaPath","newElement","addElement","Date","now","addBlock","error","errorElement","message","elementNode","block","existingNode","blockNode"],"sources":["../src/AppNode.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { produce } from \"immer\"\n\nimport {\n  getLoadingScreenType,\n  isNullOrUndefined,\n  LoadingScreenType,\n  makeAppSkeletonElement,\n  makeElementWithErrorText,\n  makeElementWithInfoText,\n  notUndefined,\n} from \"@streamlit/lib/src/util/utils\"\n\nimport {\n  ArrowNamedDataSet,\n  Arrow as ArrowProto,\n  ArrowVegaLiteChart as ArrowVegaLiteChartProto,\n  Block as BlockProto,\n  Delta,\n  Element,\n  ForwardMsgMetadata,\n  IArrow,\n  IArrowNamedDataSet,\n  Logo,\n} from \"./proto\"\nimport {\n  VegaLiteChartElement,\n  WrappedNamedDataset,\n} from \"./components/elements/ArrowVegaLiteChart\"\nimport { Quiver } from \"./dataframes/Quiver\"\nimport { ensureError } from \"./util/ErrorHandling\"\n\nconst NO_SCRIPT_RUN_ID = \"NO_SCRIPT_RUN_ID\"\n\ninterface LogoMetadata {\n  // Associated scriptHash that created the logo\n  activeScriptHash: string\n\n  // Associated scriptRunId that created the logo\n  scriptRunId: string\n}\ninterface AppLogo extends LogoMetadata {\n  logo: Logo\n}\n\n/**\n * An immutable node of the \"App Data Tree\".\n *\n * Trees are composed of `ElementNode` leaves, which contain data about\n * a single visual element, and `BlockNode` branches, which determine the\n * layout of a group of children nodes.\n *\n * A simple tree might look like this:\n *\n *   AppRoot\n *   ├── BlockNode (\"main\")\n *   │   ├── ElementNode (text: \"Ahoy, Streamlit!\")\n *   │   └── ElementNode (button: \"Don't Push This\")\n *   └── BlockNode (\"sidebar\")\n *       └── ElementNode (checkbox: \"Batten The Hatches\")\n *\n * To build this tree, the frontend receives `Delta` messages from Python,\n * each of which corresponds to a tree mutation (\"add an element\",\n * \"add a block\", \"add rows to an existing element\"). The frontend builds the\n * tree bit by bit in response to these `Delta`s.\n *\n * To render the app, the `AppView` class walks this tree and outputs\n * a corresponding DOM structure, using React, that's essentially a mapping\n * of `AppElement` -> `ReactNode`. This rendering happens \"live\" - that is,\n * the app is re-rendered each time a new `Delta` is received.\n *\n * Because the app gets re-rendered frequently, updates need to be fast.\n * Our React components - the building blocks of the app - are \"pure\"\n * (see https://reactjs.org/docs/react-api.html#reactpurecomponent), which\n * means that React uses shallow comparison to determine which ReactNodes to\n * update.\n *\n * Thus, each node in our tree is _immutable_ - any change to a `AppNode`\n * actually results in a *new* `AppNode` instance. This occurs recursively,\n * so inserting a new `ElementNode` into the tree will also result in new\n * `BlockNode`s for each of that Element's ancestors, all the way up to the\n * root node. Then, when React re-renders the app, it will re-traverse the new\n * nodes that have been created, and rebuild just the bits of the app that\n * have changed.\n */\nexport interface AppNode {\n  /**\n   * The ID of the script run this node was generated in. When a script finishes\n   * running, the app prunes all stale nodes.\n   */\n  readonly scriptRunId: string\n\n  /**\n   * The ID of the fragment that sent the Delta creating this AppNode. If this\n   * AppNode was not created by a fragment, this field is falsy.\n   */\n  readonly fragmentId?: string\n\n  /**\n   * The hash of the script that created this node.\n   */\n  readonly activeScriptHash?: string\n\n  // A timestamp indicating based on which delta message the node was created.\n  // If the node was created without a delta message, this field is undefined.\n  // This helps us to update React components based on a new backend message even though other\n  // props have not changed; this can happen for UI-only interactions such as dimissing a dialog.\n  readonly deltaMsgReceivedAt?: number\n\n  /**\n   * Return the AppNode for the given index path, or undefined if the path\n   * is invalid.\n   */\n  getIn(path: number[]): AppNode | undefined\n\n  /**\n   * Return a copy of this node with a new element set at the given index\n   * path. Throws an error if the path is invalid.\n   */\n  setIn(path: number[], node: AppNode, scriptRunId: string): AppNode\n\n  /**\n   * Recursively remove children nodes whose activeScriptHash is no longer\n   * associated with the mainScriptHash.\n   */\n  filterMainScriptElements(mainScriptHash: string): AppNode | undefined\n\n  /**\n   * Recursively remove children nodes whose scriptRunId is no longer current.\n   * If this node should no longer exist, return undefined.\n   */\n  clearStaleNodes(\n    currentScriptRunId: string,\n    fragmentIdsThisRun?: Array<string>,\n    fragmentIdOfBlock?: string\n  ): AppNode | undefined\n\n  /**\n   * Return a Set of all the Elements contained in the tree.\n   * If an existing Set is passed in, that Set will be mutated and returned.\n   * Otherwise, a new Set will be created and will be returned.\n   */\n  getElements(elementSet?: Set<Element>): Set<Element>\n}\n\n/**\n * A leaf AppNode. Contains a single element to render.\n */\nexport class ElementNode implements AppNode {\n  public readonly element: Element\n\n  public readonly metadata: ForwardMsgMetadata\n\n  public readonly scriptRunId: string\n\n  public readonly fragmentId?: string\n\n  private lazyQuiverElement?: Quiver\n\n  private lazyVegaLiteChartElement?: VegaLiteChartElement\n\n  // The hash of the script that created this element.\n  public readonly activeScriptHash: string\n\n  /** Create a new ElementNode. */\n  public constructor(\n    element: Element,\n    metadata: ForwardMsgMetadata,\n    scriptRunId: string,\n    activeScriptHash: string,\n    fragmentId?: string\n  ) {\n    this.element = element\n    this.metadata = metadata\n    this.scriptRunId = scriptRunId\n    this.activeScriptHash = activeScriptHash\n    this.fragmentId = fragmentId\n  }\n\n  public get quiverElement(): Quiver {\n    if (this.lazyQuiverElement !== undefined) {\n      return this.lazyQuiverElement\n    }\n\n    if (\n      this.element.type !== \"arrowTable\" &&\n      this.element.type !== \"arrowDataFrame\"\n    ) {\n      throw new Error(\n        `elementType '${this.element.type}' is not a valid Quiver element!`\n      )\n    }\n\n    const toReturn = new Quiver(this.element[this.element.type] as ArrowProto)\n    // TODO (lukasmasuch): Delete element from proto object?\n    this.lazyQuiverElement = toReturn\n    return toReturn\n  }\n\n  public get vegaLiteChartElement(): VegaLiteChartElement {\n    if (this.lazyVegaLiteChartElement !== undefined) {\n      return this.lazyVegaLiteChartElement\n    }\n\n    if (this.element.type !== \"arrowVegaLiteChart\") {\n      throw new Error(\n        `elementType '${this.element.type}' is not a valid VegaLiteChartElement!`\n      )\n    }\n\n    const proto = this.element.arrowVegaLiteChart as ArrowVegaLiteChartProto\n    const modifiedData = proto.data ? new Quiver(proto.data) : null\n    const modifiedDatasets =\n      proto.datasets.length > 0 ? wrapDatasets(proto.datasets) : []\n\n    const toReturn = {\n      data: modifiedData,\n      spec: proto.spec,\n      datasets: modifiedDatasets,\n      useContainerWidth: proto.useContainerWidth,\n      vegaLiteTheme: proto.theme,\n      id: proto.id,\n      selectionMode: proto.selectionMode,\n      formId: proto.formId,\n    }\n\n    this.lazyVegaLiteChartElement = toReturn\n    return toReturn\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getIn(): AppNode | undefined {\n    return undefined\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public setIn(): AppNode {\n    throw new Error(\"'setIn' cannot be called on an ElementNode\")\n  }\n\n  public filterMainScriptElements(\n    mainScriptHash: string\n  ): AppNode | undefined {\n    if (this.activeScriptHash !== mainScriptHash) {\n      return undefined\n    }\n\n    return this\n  }\n\n  public clearStaleNodes(\n    currentScriptRunId: string,\n    fragmentIdsThisRun?: Array<string>,\n    fragmentIdOfBlock?: string\n  ): ElementNode | undefined {\n    if (fragmentIdsThisRun && fragmentIdsThisRun.length) {\n      // If we're currently running a fragment, nodes unrelated to the fragment\n      // shouldn't be cleared. This can happen when,\n      //   1. This element doesn't correspond to a fragment at all.\n      //   2. This element is a fragment but is in no path that was modified.\n      //   3. This element belongs to a path that was modified, but it was modified in the same run.\n      if (\n        !this.fragmentId ||\n        !fragmentIdOfBlock ||\n        this.scriptRunId === currentScriptRunId\n      ) {\n        return this\n      }\n    }\n    return this.scriptRunId === currentScriptRunId ? this : undefined\n  }\n\n  public getElements(elements?: Set<Element>): Set<Element> {\n    if (isNullOrUndefined(elements)) {\n      elements = new Set<Element>()\n    }\n    elements.add(this.element)\n    return elements\n  }\n\n  public arrowAddRows(\n    namedDataSet: ArrowNamedDataSet,\n    scriptRunId: string\n  ): ElementNode {\n    const elementType = this.element.type\n    const newNode = new ElementNode(\n      this.element,\n      this.metadata,\n      scriptRunId,\n      this.activeScriptHash,\n      this.fragmentId\n    )\n\n    switch (elementType) {\n      case \"arrowTable\":\n      case \"arrowDataFrame\": {\n        newNode.lazyQuiverElement = ElementNode.quiverAddRowsHelper(\n          this.quiverElement,\n          namedDataSet\n        )\n        break\n      }\n      case \"arrowVegaLiteChart\": {\n        newNode.lazyVegaLiteChartElement =\n          ElementNode.vegaLiteChartAddRowsHelper(\n            this.vegaLiteChartElement,\n            namedDataSet\n          )\n        break\n      }\n      default: {\n        // This should never happen!\n        throw new Error(\n          `elementType '${this.element.type}' is not a valid arrowAddRows target!`\n        )\n      }\n    }\n\n    return newNode\n  }\n\n  private static quiverAddRowsHelper(\n    element: Quiver,\n    namedDataSet: ArrowNamedDataSet\n  ): Quiver {\n    if (namedDataSet.hasName) {\n      throw new Error(\n        \"Add rows cannot be used with a named dataset for this element.\"\n      )\n    }\n\n    const newQuiver = new Quiver(namedDataSet.data as IArrow)\n    return element.addRows(newQuiver)\n  }\n\n  private static vegaLiteChartAddRowsHelper(\n    element: VegaLiteChartElement,\n    namedDataSet: ArrowNamedDataSet\n  ): VegaLiteChartElement {\n    const newDataSetName = namedDataSet.hasName ? namedDataSet.name : null\n    const newDataSetQuiver = new Quiver(namedDataSet.data as IArrow)\n\n    return produce(element, (draft: VegaLiteChartElement) => {\n      const existingDataSet = getNamedDataSet(draft.datasets, newDataSetName)\n      if (existingDataSet) {\n        existingDataSet.data = existingDataSet.data.addRows(newDataSetQuiver)\n      } else {\n        draft.data = draft.data\n          ? draft.data.addRows(newDataSetQuiver)\n          : newDataSetQuiver\n      }\n    })\n  }\n}\n\n/**\n * If there is only one NamedDataSet, return it.\n * If there is a NamedDataset that matches the given name, return it.\n * Otherwise, return `undefined`.\n */\nfunction getNamedDataSet(\n  namedDataSets: WrappedNamedDataset[],\n  name: string | null\n): WrappedNamedDataset | undefined {\n  if (namedDataSets.length === 1) {\n    return namedDataSets[0]\n  }\n\n  return namedDataSets.find(\n    (dataset: WrappedNamedDataset) => dataset.hasName && dataset.name === name\n  )\n}\n\n/**\n * A container AppNode that holds children.\n */\nexport class BlockNode implements AppNode {\n  public readonly children: AppNode[]\n\n  public readonly deltaBlock: BlockProto\n\n  public readonly scriptRunId: string\n\n  public readonly fragmentId?: string\n\n  public readonly deltaMsgReceivedAt?: number\n\n  // The hash of the script that created this block.\n  public readonly activeScriptHash: string\n\n  public constructor(\n    activeScriptHash: string,\n    children?: AppNode[],\n    deltaBlock?: BlockProto,\n    scriptRunId?: string,\n    fragmentId?: string,\n    deltaMsgReceivedAt?: number\n  ) {\n    this.activeScriptHash = activeScriptHash\n    this.children = children ?? []\n    this.deltaBlock = deltaBlock ?? new BlockProto({})\n    this.scriptRunId = scriptRunId ?? NO_SCRIPT_RUN_ID\n    this.fragmentId = fragmentId\n    this.deltaMsgReceivedAt = deltaMsgReceivedAt\n  }\n\n  /** True if this Block has no children. */\n  public get isEmpty(): boolean {\n    return this.children.length === 0\n  }\n\n  public getIn(path: number[]): AppNode | undefined {\n    if (path.length === 0) {\n      return undefined\n    }\n\n    const childIndex = path[0]\n    if (childIndex < 0 || childIndex >= this.children.length) {\n      return undefined\n    }\n\n    if (path.length === 1) {\n      return this.children[childIndex]\n    }\n\n    return this.children[childIndex].getIn(path.slice(1))\n  }\n\n  public setIn(path: number[], node: AppNode, scriptRunId: string): BlockNode {\n    if (path.length === 0) {\n      throw new Error(`empty path!`)\n    }\n\n    const childIndex = path[0]\n    if (childIndex < 0 || childIndex > this.children.length) {\n      throw new Error(\n        `Bad 'setIn' index ${childIndex} (should be between [0, ${this.children.length}])`\n      )\n    }\n\n    const newChildren = this.children.slice()\n    if (path.length === 1) {\n      // Base case\n      newChildren[childIndex] = node\n    } else {\n      // Pop the current element off our path, and recurse into our children\n      newChildren[childIndex] = newChildren[childIndex].setIn(\n        path.slice(1),\n        node,\n        scriptRunId\n      )\n    }\n\n    return new BlockNode(\n      this.activeScriptHash,\n      newChildren,\n      this.deltaBlock,\n      scriptRunId,\n      this.fragmentId,\n      this.deltaMsgReceivedAt\n    )\n  }\n\n  filterMainScriptElements(mainScriptHash: string): AppNode | undefined {\n    if (this.activeScriptHash !== mainScriptHash) {\n      return undefined\n    }\n\n    // Recursively clear our children.\n    const newChildren = this.children\n      .map(child => child.filterMainScriptElements(mainScriptHash))\n      .filter(notUndefined)\n\n    return new BlockNode(\n      this.activeScriptHash,\n      newChildren,\n      this.deltaBlock,\n      this.scriptRunId,\n      this.fragmentId,\n      this.deltaMsgReceivedAt\n    )\n  }\n\n  public clearStaleNodes(\n    currentScriptRunId: string,\n    fragmentIdsThisRun?: Array<string>,\n    fragmentIdOfBlock?: string\n  ): BlockNode | undefined {\n    if (!fragmentIdsThisRun || !fragmentIdsThisRun.length) {\n      // If we're not currently running a fragment, then we can remove any blocks\n      // that don't correspond to currentScriptRunId.\n      if (this.scriptRunId !== currentScriptRunId) {\n        return undefined\n      }\n    } else {\n      // Otherwise, we are currently running a fragment, and our behavior\n      // depends on the fragmentId of this BlockNode.\n\n      // The parent block was modified but this element wasn't, so it's stale.\n      if (fragmentIdOfBlock && this.scriptRunId !== currentScriptRunId) {\n        return undefined\n      }\n\n      // This block is modified by the current run, so we indicate this to our children in case\n      // they were not modified by the current run, which means they are stale.\n      if (\n        this.fragmentId &&\n        fragmentIdsThisRun.includes(this.fragmentId) &&\n        this.scriptRunId === currentScriptRunId\n      ) {\n        fragmentIdOfBlock = this.fragmentId\n      }\n    }\n\n    // Recursively clear our children.\n    const newChildren = this.children\n      .map(child => {\n        return child.clearStaleNodes(\n          currentScriptRunId,\n          fragmentIdsThisRun,\n          fragmentIdOfBlock\n        )\n      })\n      .filter(notUndefined)\n\n    return new BlockNode(\n      this.activeScriptHash,\n      newChildren,\n      this.deltaBlock,\n      currentScriptRunId,\n      this.fragmentId,\n      this.deltaMsgReceivedAt\n    )\n  }\n\n  public getElements(elementSet?: Set<Element>): Set<Element> {\n    if (isNullOrUndefined(elementSet)) {\n      elementSet = new Set<Element>()\n    }\n\n    for (const child of this.children) {\n      child.getElements(elementSet)\n    }\n\n    return elementSet\n  }\n}\n\n/**\n * The root of our data tree. It contains the app's top-level BlockNodes.\n */\nexport class AppRoot {\n  readonly root: BlockNode\n\n  /* The hash of the main script that creates this AppRoot. */\n  readonly mainScriptHash: string\n\n  readonly appLogo: AppLogo | null\n\n  /**\n   * Create an empty AppRoot with a placeholder \"skeleton\" element.\n   */\n  public static empty(\n    mainScriptHash = \"\",\n    isInitialRender = true,\n    sidebarElements?: BlockNode | undefined,\n    logo?: Logo | null\n  ): AppRoot {\n    const mainNodes: AppNode[] = []\n\n    let waitElement: Element | undefined\n\n    switch (getLoadingScreenType()) {\n      case LoadingScreenType.NONE:\n        break\n\n      case LoadingScreenType.V1:\n        // Only show the v1 loading state when it's the initial render.\n        // This is how v1 used to work, and we don't want any backward\n        // incompatibility.\n        if (isInitialRender) {\n          waitElement = makeElementWithInfoText(\"Please wait...\")\n        }\n        break\n\n      default:\n        waitElement = makeAppSkeletonElement()\n    }\n\n    if (waitElement) {\n      mainNodes.push(\n        new ElementNode(\n          waitElement,\n          ForwardMsgMetadata.create({}),\n          NO_SCRIPT_RUN_ID,\n          mainScriptHash\n        )\n      )\n    }\n\n    const main = new BlockNode(\n      mainScriptHash,\n      mainNodes,\n      new BlockProto({ allowEmpty: true }),\n      NO_SCRIPT_RUN_ID\n    )\n\n    const sidebar =\n      sidebarElements ||\n      new BlockNode(\n        mainScriptHash,\n        [],\n        new BlockProto({ allowEmpty: true }),\n        NO_SCRIPT_RUN_ID\n      )\n\n    const event = new BlockNode(\n      mainScriptHash,\n      [],\n      new BlockProto({ allowEmpty: true }),\n      NO_SCRIPT_RUN_ID\n    )\n\n    const bottom = new BlockNode(\n      mainScriptHash,\n      [],\n      new BlockProto({ allowEmpty: true }),\n      NO_SCRIPT_RUN_ID\n    )\n\n    // Persist logo between pages to avoid flicker (MPA V1 - Issue #8815)\n    const appLogo = logo\n      ? {\n          logo,\n          activeScriptHash: mainScriptHash,\n          scriptRunId: NO_SCRIPT_RUN_ID,\n        }\n      : null\n\n    return new AppRoot(\n      mainScriptHash,\n      new BlockNode(mainScriptHash, [main, sidebar, event, bottom]),\n      appLogo\n    )\n  }\n\n  public constructor(\n    mainScriptHash: string,\n    root: BlockNode,\n    appLogo: AppLogo | null = null\n  ) {\n    this.mainScriptHash = mainScriptHash\n    this.root = root\n    this.appLogo = appLogo\n\n    // Verify that our root node has exactly 4 children: a 'main' block,\n    // a 'sidebar' block, a `bottom` block and an 'event' block.\n    if (\n      this.root.children.length !== 4 ||\n      isNullOrUndefined(this.main) ||\n      isNullOrUndefined(this.sidebar) ||\n      isNullOrUndefined(this.event) ||\n      isNullOrUndefined(this.bottom)\n    ) {\n      throw new Error(`Invalid root node children! ${root}`)\n    }\n  }\n\n  public get main(): BlockNode {\n    const [main] = this.root.children\n    return main as BlockNode\n  }\n\n  public get sidebar(): BlockNode {\n    const [, sidebar] = this.root.children\n    return sidebar as BlockNode\n  }\n\n  public get event(): BlockNode {\n    const [, , event] = this.root.children\n    return event as BlockNode\n  }\n\n  public get bottom(): BlockNode {\n    const [, , , bottom] = this.root.children\n    return bottom as BlockNode\n  }\n\n  public get logo(): Logo | null {\n    return this.appLogo?.logo ?? null\n  }\n\n  public appRootWithLogo(logo: Logo, metadata: LogoMetadata): AppRoot {\n    return new AppRoot(this.mainScriptHash, this.root, {\n      logo,\n      ...metadata,\n    })\n  }\n\n  public applyDelta(\n    scriptRunId: string,\n    delta: Delta,\n    metadata: ForwardMsgMetadata\n  ): AppRoot {\n    // The full path to the AppNode within the element tree.\n    // Used to find and update the element node specified by this Delta.\n    const { deltaPath, activeScriptHash } = metadata\n    switch (delta.type) {\n      case \"newElement\": {\n        const element = delta.newElement as Element\n        return this.addElement(\n          deltaPath,\n          scriptRunId,\n          element,\n          metadata,\n          activeScriptHash,\n          delta.fragmentId\n        )\n      }\n\n      case \"addBlock\": {\n        const deltaMsgReceivedAt = Date.now()\n        return this.addBlock(\n          deltaPath,\n          delta.addBlock as BlockProto,\n          scriptRunId,\n          activeScriptHash,\n          delta.fragmentId,\n          deltaMsgReceivedAt\n        )\n      }\n\n      case \"arrowAddRows\": {\n        try {\n          return this.arrowAddRows(\n            deltaPath,\n            delta.arrowAddRows as ArrowNamedDataSet,\n            scriptRunId\n          )\n        } catch (error) {\n          const errorElement = makeElementWithErrorText(\n            ensureError(error).message\n          )\n          return this.addElement(\n            deltaPath,\n            scriptRunId,\n            errorElement,\n            metadata,\n            activeScriptHash\n          )\n        }\n      }\n\n      default: {\n        throw new Error(`Unrecognized deltaType: '${delta.type}'`)\n      }\n    }\n  }\n\n  filterMainScriptElements(mainScriptHash: string): AppRoot {\n    // clears all nodes that are not associated with the mainScriptHash\n    // Get the current script run id from one of the children\n    const currentScriptRunId = this.main.scriptRunId\n    const main =\n      this.main.filterMainScriptElements(mainScriptHash) ||\n      new BlockNode(mainScriptHash)\n    const sidebar =\n      this.sidebar.filterMainScriptElements(mainScriptHash) ||\n      new BlockNode(mainScriptHash)\n    const event =\n      this.event.filterMainScriptElements(mainScriptHash) ||\n      new BlockNode(mainScriptHash)\n    const bottom =\n      this.bottom.filterMainScriptElements(mainScriptHash) ||\n      new BlockNode(mainScriptHash)\n    const appLogo =\n      this.appLogo?.activeScriptHash === mainScriptHash ? this.appLogo : null\n\n    return new AppRoot(\n      mainScriptHash,\n      new BlockNode(\n        mainScriptHash,\n        [main, sidebar, event, bottom],\n        new BlockProto({ allowEmpty: true }),\n        currentScriptRunId\n      ),\n      appLogo\n    )\n  }\n\n  public clearStaleNodes(\n    currentScriptRunId: string,\n    fragmentIdsThisRun?: Array<string>\n  ): AppRoot {\n    const main =\n      this.main.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||\n      new BlockNode(this.mainScriptHash)\n    const sidebar =\n      this.sidebar.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||\n      new BlockNode(this.mainScriptHash)\n    const event =\n      this.event.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||\n      new BlockNode(this.mainScriptHash)\n    const bottom =\n      this.bottom.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||\n      new BlockNode(this.mainScriptHash)\n\n    const appLogo =\n      this.appLogo?.scriptRunId === currentScriptRunId ? this.appLogo : null\n\n    return new AppRoot(\n      this.mainScriptHash,\n      new BlockNode(\n        this.mainScriptHash,\n        [main, sidebar, event, bottom],\n        new BlockProto({ allowEmpty: true }),\n        currentScriptRunId\n      ),\n      appLogo\n    )\n  }\n\n  /** Return a Set containing all Elements in the tree. */\n  public getElements(): Set<Element> {\n    const elements = new Set<Element>()\n    this.main.getElements(elements)\n    this.sidebar.getElements(elements)\n    this.event.getElements(elements)\n    this.bottom.getElements(elements)\n    return elements\n  }\n\n  private addElement(\n    deltaPath: number[],\n    scriptRunId: string,\n    element: Element,\n    metadata: ForwardMsgMetadata,\n    activeScriptHash: string,\n    fragmentId?: string\n  ): AppRoot {\n    const elementNode = new ElementNode(\n      element,\n      metadata,\n      scriptRunId,\n      activeScriptHash,\n      fragmentId\n    )\n    return new AppRoot(\n      this.mainScriptHash,\n      this.root.setIn(deltaPath, elementNode, scriptRunId),\n      this.appLogo\n    )\n  }\n\n  private addBlock(\n    deltaPath: number[],\n    block: BlockProto,\n    scriptRunId: string,\n    activeScriptHash: string,\n    fragmentId?: string,\n    deltaMsgReceivedAt?: number\n  ): AppRoot {\n    const existingNode = this.root.getIn(deltaPath)\n\n    // If we're replacing an existing Block of the same type, this new Block\n    // inherits the existing Block's children. This preserves two things:\n    //  1. Widget State\n    //  2. React state of all elements\n    let children: AppNode[] = []\n    if (\n      existingNode instanceof BlockNode &&\n      existingNode.deltaBlock.type === block.type\n    ) {\n      children = existingNode.children\n    }\n\n    const blockNode = new BlockNode(\n      activeScriptHash,\n      children,\n      block,\n      scriptRunId,\n      fragmentId,\n      deltaMsgReceivedAt\n    )\n    return new AppRoot(\n      this.mainScriptHash,\n      this.root.setIn(deltaPath, blockNode, scriptRunId),\n      this.appLogo\n    )\n  }\n\n  private arrowAddRows(\n    deltaPath: number[],\n    namedDataSet: ArrowNamedDataSet,\n    scriptRunId: string\n  ): AppRoot {\n    const existingNode = this.root.getIn(deltaPath) as ElementNode\n    if (isNullOrUndefined(existingNode)) {\n      throw new Error(`Can't arrowAddRows: invalid deltaPath: ${deltaPath}`)\n    }\n\n    const elementNode = existingNode.arrowAddRows(namedDataSet, scriptRunId)\n    return new AppRoot(\n      this.mainScriptHash,\n      this.root.setIn(deltaPath, elementNode, scriptRunId),\n      this.appLogo\n    )\n  }\n}\n\n/** Iterates over datasets and converts data to Quiver. */\nfunction wrapDatasets(datasets: IArrowNamedDataSet[]): WrappedNamedDataset[] {\n  return datasets.map((dataset: IArrowNamedDataSet) => {\n    return {\n      hasName: dataset.hasName as boolean,\n      name: dataset.name as string,\n      data: new Quiver(dataset.data as IArrow),\n    }\n  })\n}\n"],"mappings":"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"}