{"version":3,"file":"AppNode.js","names":["produce","Block","BlockProto","ForwardMsgMetadata","Quiver","ensureError","getLoadingScreenType","LoadingScreenType","makeElementWithErrorText","makeElementWithInfoText","makeAppSkeletonElement","notUndefined","NO_SCRIPT_RUN_ID","ElementNode","constructor","element","metadata","scriptRunId","activeScriptHash","fragmentId","lazyQuiverElement","lazyVegaLiteChartElement","quiverElement","undefined","type","Error","concat","toReturn","vegaLiteChartElement","proto","arrowVegaLiteChart","modifiedData","data","modifiedDatasets","datasets","length","wrapDatasets","spec","useContainerWidth","vegaLiteTheme","theme","id","selectionMode","formId","getIn","setIn","filterMainScriptElements","mainScriptHash","clearStaleNodes","currentScriptRunId","fragmentIdsThisRun","fragmentIdOfBlock","includes","getElements","elements","Set","add","arrowAddRows","namedDataSet","elementType","newNode","quiverAddRowsHelper","vegaLiteChartAddRowsHelper","hasName","newQuiver","addRows","newDataSetName","name","newDataSetQuiver","draft","existingDataSet","getNamedDataSet","namedDataSets","find","dataset","BlockNode","children","deltaBlock","isEmpty","path","childIndex","slice","node","newChildren","map","child","filter","elementSet","AppRoot","empty","arguments","isInitialRender","sidebarElements","mainNodes","waitElement","NONE","V1","push","create","main","allowEmpty","sidebar","event","bottom","root","appLogo","logo","_this$appLogo$logo","_this$appLogo","appRootWithLogo","applyDelta","delta","deltaPath","newElement","addElement","addBlock","error","errorElement","message","_this$appLogo2","elementNode","block","existingNode","blockNode"],"sources":["../src/AppNode.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { produce } from \"immer\"\nimport {\n  Arrow as ArrowProto,\n  ArrowNamedDataSet,\n  ArrowVegaLiteChart as ArrowVegaLiteChartProto,\n  Block as BlockProto,\n  Delta,\n  Element,\n  ForwardMsgMetadata,\n  IArrow,\n  IArrowNamedDataSet,\n  Logo,\n} from \"./proto\"\nimport {\n  VegaLiteChartElement,\n  WrappedNamedDataset,\n} from \"./components/elements/ArrowVegaLiteChart\"\nimport { Quiver } from \"./dataframes/Quiver\"\nimport { ensureError } from \"./util/ErrorHandling\"\nimport {\n  getLoadingScreenType,\n  LoadingScreenType,\n  makeElementWithErrorText,\n  makeElementWithInfoText,\n  makeAppSkeletonElement,\n  notUndefined,\n} from \"./util/utils\"\n\nconst NO_SCRIPT_RUN_ID = \"NO_SCRIPT_RUN_ID\"\ninterface AppLogo {\n  logo: Logo\n  // Associated scriptHash that created the logo\n  activeScriptHash: string\n}\n\n/**\n * An immutable node of the \"App Data Tree\".\n *\n * Trees are composed of `ElementNode` leaves, which contain data about\n * a single visual element, and `BlockNode` branches, which determine the\n * layout of a group of children nodes.\n *\n * A simple tree might look like this:\n *\n *   AppRoot\n *   ├── BlockNode (\"main\")\n *   │   ├── ElementNode (text: \"Ahoy, Streamlit!\")\n *   │   └── ElementNode (button: \"Don't Push This\")\n *   └── BlockNode (\"sidebar\")\n *       └── ElementNode (checkbox: \"Batten The Hatches\")\n *\n * To build this tree, the frontend receives `Delta` messages from Python,\n * each of which corresponds to a tree mutation (\"add an element\",\n * \"add a block\", \"add rows to an existing element\"). The frontend builds the\n * tree bit by bit in response to these `Delta`s.\n *\n * To render the app, the `AppView` class walks this tree and outputs\n * a corresponding DOM structure, using React, that's essentially a mapping\n * of `AppElement` -> `ReactNode`. This rendering happens \"live\" - that is,\n * the app is re-rendered each time a new `Delta` is received.\n *\n * Because the app gets re-rendered frequently, updates need to be fast.\n * Our React components - the building blocks of the app - are \"pure\"\n * (see https://reactjs.org/docs/react-api.html#reactpurecomponent), which\n * means that React uses shallow comparison to determine which ReactNodes to\n * update.\n *\n * Thus, each node in our tree is _immutable_ - any change to a `AppNode`\n * actually results in a *new* `AppNode` instance. This occurs recursively,\n * so inserting a new `ElementNode` into the tree will also result in new\n * `BlockNode`s for each of that Element's ancestors, all the way up to the\n * root node. Then, when React re-renders the app, it will re-traverse the new\n * nodes that have been created, and rebuild just the bits of the app that\n * have changed.\n */\nexport interface AppNode {\n  /**\n   * The ID of the script run this node was generated in. When a script finishes\n   * running, the app prunes all stale nodes.\n   */\n  readonly scriptRunId: string\n\n  /**\n   * The ID of the fragment that sent the Delta creating this AppNode. If this\n   * AppNode was not created by a fragment, this field is falsy.\n   */\n  readonly fragmentId?: string\n\n  /**\n   * The hash of the script that created this node.\n   */\n  readonly activeScriptHash?: string\n\n  /**\n   * Return the AppNode for the given index path, or undefined if the path\n   * is invalid.\n   */\n  getIn(path: number[]): AppNode | undefined\n\n  /**\n   * Return a copy of this node with a new element set at the given index\n   * path. Throws an error if the path is invalid.\n   */\n  setIn(path: number[], node: AppNode, scriptRunId: string): AppNode\n\n  /**\n   * Recursively remove children nodes whose activeScriptHash is no longer\n   * associated with the mainScriptHash.\n   */\n  filterMainScriptElements(mainScriptHash: string): AppNode | undefined\n\n  /**\n   * Recursively remove children nodes whose scriptRunId is no longer current.\n   * If this node should no longer exist, return undefined.\n   */\n  clearStaleNodes(\n    currentScriptRunId: string,\n    fragmentIdsThisRun?: Array<string>,\n    fragmentIdOfBlock?: string\n  ): AppNode | undefined\n\n  /**\n   * Return a Set of all the Elements contained in the tree.\n   * If an existing Set is passed in, that Set will be mutated and returned.\n   * Otherwise, a new Set will be created and will be returned.\n   */\n  getElements(elementSet?: Set<Element>): Set<Element>\n}\n\n/**\n * A leaf AppNode. Contains a single element to render.\n */\nexport class ElementNode implements AppNode {\n  public readonly element: Element\n\n  public readonly metadata: ForwardMsgMetadata\n\n  public readonly scriptRunId: string\n\n  public readonly fragmentId?: string\n\n  private lazyQuiverElement?: Quiver\n\n  private lazyVegaLiteChartElement?: VegaLiteChartElement\n\n  // The hash of the script that created this element.\n  public readonly activeScriptHash: string\n\n  /** Create a new ElementNode. */\n  public constructor(\n    element: Element,\n    metadata: ForwardMsgMetadata,\n    scriptRunId: string,\n    activeScriptHash: string,\n    fragmentId?: string\n  ) {\n    this.element = element\n    this.metadata = metadata\n    this.scriptRunId = scriptRunId\n    this.activeScriptHash = activeScriptHash\n    this.fragmentId = fragmentId\n  }\n\n  public get quiverElement(): Quiver {\n    if (this.lazyQuiverElement !== undefined) {\n      return this.lazyQuiverElement\n    }\n\n    if (\n      this.element.type !== \"arrowTable\" &&\n      this.element.type !== \"arrowDataFrame\"\n    ) {\n      throw new Error(\n        `elementType '${this.element.type}' is not a valid Quiver element!`\n      )\n    }\n\n    const toReturn = new Quiver(this.element[this.element.type] as ArrowProto)\n    // TODO (lukasmasuch): Delete element from proto object?\n    this.lazyQuiverElement = toReturn\n    return toReturn\n  }\n\n  public get vegaLiteChartElement(): VegaLiteChartElement {\n    if (this.lazyVegaLiteChartElement !== undefined) {\n      return this.lazyVegaLiteChartElement\n    }\n\n    if (this.element.type !== \"arrowVegaLiteChart\") {\n      throw new Error(\n        `elementType '${this.element.type}' is not a valid VegaLiteChartElement!`\n      )\n    }\n\n    const proto = this.element.arrowVegaLiteChart as ArrowVegaLiteChartProto\n    const modifiedData = proto.data ? new Quiver(proto.data) : null\n    const modifiedDatasets =\n      proto.datasets.length > 0 ? wrapDatasets(proto.datasets) : []\n\n    const toReturn = {\n      data: modifiedData,\n      spec: proto.spec,\n      datasets: modifiedDatasets,\n      useContainerWidth: proto.useContainerWidth,\n      vegaLiteTheme: proto.theme,\n      id: proto.id,\n      selectionMode: proto.selectionMode,\n      formId: proto.formId,\n    }\n\n    this.lazyVegaLiteChartElement = toReturn\n    return toReturn\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getIn(): AppNode | undefined {\n    return undefined\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public setIn(): AppNode {\n    throw new Error(\"'setIn' cannot be called on an ElementNode\")\n  }\n\n  public filterMainScriptElements(\n    mainScriptHash: string\n  ): AppNode | undefined {\n    if (this.activeScriptHash !== mainScriptHash) {\n      return undefined\n    }\n\n    return this\n  }\n\n  public clearStaleNodes(\n    currentScriptRunId: string,\n    fragmentIdsThisRun?: Array<string>,\n    fragmentIdOfBlock?: string\n  ): ElementNode | undefined {\n    if (fragmentIdsThisRun && fragmentIdsThisRun.length) {\n      // If we're currently running a fragment, nodes unrelated to the fragment\n      // shouldn't be cleared. This can happen when,\n      //   1. This element doesn't correspond to a fragment at all.\n      //   2. This element corresponds to a fragment, but not one that's\n      //      currently being run.\n      //   3. This element was added by a fragment, but the element's\n      //      *parent block* does not correspond to the same fragment. This is\n      //      possible when a fragment writes to a container defined outside of\n      //      itself. We don't clear out these types of elements in this case\n      //      as we don't want fragment runs to result in changes to externally\n      //      defined containers.\n      if (\n        !this.fragmentId ||\n        !fragmentIdsThisRun.includes(this.fragmentId) ||\n        this.fragmentId != fragmentIdOfBlock\n      ) {\n        return this\n      }\n    }\n    return this.scriptRunId === currentScriptRunId ? this : undefined\n  }\n\n  public getElements(elements?: Set<Element>): Set<Element> {\n    if (elements == null) {\n      elements = new Set<Element>()\n    }\n    elements.add(this.element)\n    return elements\n  }\n\n  public arrowAddRows(\n    namedDataSet: ArrowNamedDataSet,\n    scriptRunId: string\n  ): ElementNode {\n    const elementType = this.element.type\n    const newNode = new ElementNode(\n      this.element,\n      this.metadata,\n      scriptRunId,\n      this.activeScriptHash,\n      this.fragmentId\n    )\n\n    switch (elementType) {\n      case \"arrowTable\":\n      case \"arrowDataFrame\": {\n        newNode.lazyQuiverElement = ElementNode.quiverAddRowsHelper(\n          this.quiverElement,\n          namedDataSet\n        )\n        break\n      }\n      case \"arrowVegaLiteChart\": {\n        newNode.lazyVegaLiteChartElement =\n          ElementNode.vegaLiteChartAddRowsHelper(\n            this.vegaLiteChartElement,\n            namedDataSet\n          )\n        break\n      }\n      default: {\n        // This should never happen!\n        throw new Error(\n          `elementType '${this.element.type}' is not a valid arrowAddRows target!`\n        )\n      }\n    }\n\n    return newNode\n  }\n\n  private static quiverAddRowsHelper(\n    element: Quiver,\n    namedDataSet: ArrowNamedDataSet\n  ): Quiver {\n    if (namedDataSet.hasName) {\n      throw new Error(\n        \"Add rows cannot be used with a named dataset for this element.\"\n      )\n    }\n\n    const newQuiver = new Quiver(namedDataSet.data as IArrow)\n    return element.addRows(newQuiver)\n  }\n\n  private static vegaLiteChartAddRowsHelper(\n    element: VegaLiteChartElement,\n    namedDataSet: ArrowNamedDataSet\n  ): VegaLiteChartElement {\n    const newDataSetName = namedDataSet.hasName ? namedDataSet.name : null\n    const newDataSetQuiver = new Quiver(namedDataSet.data as IArrow)\n\n    return produce(element, (draft: VegaLiteChartElement) => {\n      const existingDataSet = getNamedDataSet(draft.datasets, newDataSetName)\n      if (existingDataSet) {\n        existingDataSet.data = existingDataSet.data.addRows(newDataSetQuiver)\n      } else {\n        draft.data = draft.data\n          ? draft.data.addRows(newDataSetQuiver)\n          : newDataSetQuiver\n      }\n    })\n  }\n}\n\n/**\n * If there is only one NamedDataSet, return it.\n * If there is a NamedDataset that matches the given name, return it.\n * Otherwise, return `undefined`.\n */\nfunction getNamedDataSet(\n  namedDataSets: WrappedNamedDataset[],\n  name: string | null\n): WrappedNamedDataset | undefined {\n  if (namedDataSets.length === 1) {\n    return namedDataSets[0]\n  }\n\n  return namedDataSets.find(\n    (dataset: WrappedNamedDataset) => dataset.hasName && dataset.name === name\n  )\n}\n\n/**\n * A container AppNode that holds children.\n */\nexport class BlockNode implements AppNode {\n  public readonly children: AppNode[]\n\n  public readonly deltaBlock: BlockProto\n\n  public readonly scriptRunId: string\n\n  public readonly fragmentId?: string\n\n  // The hash of the script that created this block.\n  public readonly activeScriptHash: string\n\n  public constructor(\n    activeScriptHash: string,\n    children?: AppNode[],\n    deltaBlock?: BlockProto,\n    scriptRunId?: string,\n    fragmentId?: string\n  ) {\n    this.activeScriptHash = activeScriptHash\n    this.children = children ?? []\n    this.deltaBlock = deltaBlock ?? new BlockProto({})\n    this.scriptRunId = scriptRunId ?? NO_SCRIPT_RUN_ID\n    this.fragmentId = fragmentId\n  }\n\n  /** True if this Block has no children. */\n  public get isEmpty(): boolean {\n    return this.children.length === 0\n  }\n\n  public getIn(path: number[]): AppNode | undefined {\n    if (path.length === 0) {\n      return undefined\n    }\n\n    const childIndex = path[0]\n    if (childIndex < 0 || childIndex >= this.children.length) {\n      return undefined\n    }\n\n    if (path.length === 1) {\n      return this.children[childIndex]\n    }\n\n    return this.children[childIndex].getIn(path.slice(1))\n  }\n\n  public setIn(path: number[], node: AppNode, scriptRunId: string): BlockNode {\n    if (path.length === 0) {\n      throw new Error(`empty path!`)\n    }\n\n    const childIndex = path[0]\n    if (childIndex < 0 || childIndex > this.children.length) {\n      throw new Error(\n        `Bad 'setIn' index ${childIndex} (should be between [0, ${this.children.length}])`\n      )\n    }\n\n    const newChildren = this.children.slice()\n    if (path.length === 1) {\n      // Base case\n      newChildren[childIndex] = node\n    } else {\n      // Pop the current element off our path, and recurse into our children\n      newChildren[childIndex] = newChildren[childIndex].setIn(\n        path.slice(1),\n        node,\n        scriptRunId\n      )\n    }\n\n    return new BlockNode(\n      this.activeScriptHash,\n      newChildren,\n      this.deltaBlock,\n      scriptRunId,\n      this.fragmentId\n    )\n  }\n\n  filterMainScriptElements(mainScriptHash: string): AppNode | undefined {\n    if (this.activeScriptHash !== mainScriptHash) {\n      return undefined\n    }\n\n    // Recursively clear our children.\n    const newChildren = this.children\n      .map(child => child.filterMainScriptElements(mainScriptHash))\n      .filter(notUndefined)\n\n    return new BlockNode(\n      this.activeScriptHash,\n      newChildren,\n      this.deltaBlock,\n      this.scriptRunId,\n      this.fragmentId\n    )\n  }\n\n  public clearStaleNodes(\n    currentScriptRunId: string,\n    fragmentIdsThisRun?: Array<string>,\n    fragmentIdOfBlock?: string\n  ): BlockNode | undefined {\n    if (!fragmentIdsThisRun || !fragmentIdsThisRun.length) {\n      // If we're not currently running a fragment, then we can remove any blocks\n      // that don't correspond to currentScriptRunId.\n      if (this.scriptRunId !== currentScriptRunId) {\n        return undefined\n      }\n    } else {\n      // Otherwise, we are currently running a fragment, and our behavior\n      // depends on the fragmentId of this BlockNode.\n\n      if (this.fragmentId) {\n        if (!fragmentIdsThisRun.includes(this.fragmentId)) {\n          // This BlockNode corresponds to a different fragment, so we know we\n          // won't be modifying it and can return early.\n          return this\n        }\n\n        // If this BlockNode *does* correspond to a currently running fragment,\n        // we recurse into it below and set the fragmentIdOfBlock parameter to\n        // keep track of which fragment this BlockNode belongs to.\n        fragmentIdOfBlock = this.fragmentId\n      }\n\n      // If this BlockNode doesn't correspond to a fragment at all, we recurse\n      // into it below as one of its children might.\n    }\n\n    // Recursively clear our children.\n    const newChildren = this.children\n      .map(child =>\n        child.clearStaleNodes(\n          currentScriptRunId,\n          fragmentIdsThisRun,\n          fragmentIdOfBlock\n        )\n      )\n      .filter(notUndefined)\n\n    return new BlockNode(\n      this.activeScriptHash,\n      newChildren,\n      this.deltaBlock,\n      currentScriptRunId,\n      this.fragmentId\n    )\n  }\n\n  public getElements(elementSet?: Set<Element>): Set<Element> {\n    if (elementSet == null) {\n      elementSet = new Set<Element>()\n    }\n\n    for (const child of this.children) {\n      child.getElements(elementSet)\n    }\n\n    return elementSet\n  }\n}\n\n/**\n * The root of our data tree. It contains the app's top-level BlockNodes.\n */\nexport class AppRoot {\n  readonly root: BlockNode\n\n  /* The hash of the main script that creates this AppRoot. */\n  readonly mainScriptHash: string\n\n  readonly appLogo: AppLogo | null\n\n  /**\n   * Create an empty AppRoot with a placeholder \"skeleton\" element.\n   */\n  public static empty(\n    mainScriptHash = \"\",\n    isInitialRender = true,\n    sidebarElements?: BlockNode | undefined\n  ): AppRoot {\n    const mainNodes: AppNode[] = []\n\n    let waitElement: Element | undefined\n\n    switch (getLoadingScreenType()) {\n      case LoadingScreenType.NONE:\n        break\n\n      case LoadingScreenType.V1:\n        // Only show the v1 loading state when it's the initial render.\n        // This is how v1 used to work, and we don't want any backward\n        // incompatibility.\n        if (isInitialRender) {\n          waitElement = makeElementWithInfoText(\"Please wait...\")\n        }\n        break\n\n      default:\n        waitElement = makeAppSkeletonElement()\n    }\n\n    if (waitElement) {\n      mainNodes.push(\n        new ElementNode(\n          waitElement,\n          ForwardMsgMetadata.create({}),\n          NO_SCRIPT_RUN_ID,\n          mainScriptHash\n        )\n      )\n    }\n\n    const main = new BlockNode(\n      mainScriptHash,\n      mainNodes,\n      new BlockProto({ allowEmpty: true }),\n      NO_SCRIPT_RUN_ID\n    )\n\n    const sidebar =\n      sidebarElements ||\n      new BlockNode(\n        mainScriptHash,\n        [],\n        new BlockProto({ allowEmpty: true }),\n        NO_SCRIPT_RUN_ID\n      )\n\n    const event = new BlockNode(\n      mainScriptHash,\n      [],\n      new BlockProto({ allowEmpty: true }),\n      NO_SCRIPT_RUN_ID\n    )\n\n    const bottom = new BlockNode(\n      mainScriptHash,\n      [],\n      new BlockProto({ allowEmpty: true }),\n      NO_SCRIPT_RUN_ID\n    )\n\n    return new AppRoot(\n      mainScriptHash,\n      new BlockNode(mainScriptHash, [main, sidebar, event, bottom]),\n      null\n    )\n  }\n\n  public constructor(\n    mainScriptHash: string,\n    root: BlockNode,\n    appLogo: AppLogo | null = null\n  ) {\n    this.mainScriptHash = mainScriptHash\n    this.root = root\n    this.appLogo = appLogo\n\n    // Verify that our root node has exactly 4 children: a 'main' block,\n    // a 'sidebar' block, a `bottom` block and an 'event' block.\n    if (\n      this.root.children.length !== 4 ||\n      this.main == null ||\n      this.sidebar == null ||\n      this.event == null ||\n      this.bottom == null\n    ) {\n      throw new Error(`Invalid root node children! ${root}`)\n    }\n  }\n\n  public get main(): BlockNode {\n    const [main] = this.root.children\n    return main as BlockNode\n  }\n\n  public get sidebar(): BlockNode {\n    const [, sidebar] = this.root.children\n    return sidebar as BlockNode\n  }\n\n  public get event(): BlockNode {\n    const [, , event] = this.root.children\n    return event as BlockNode\n  }\n\n  public get bottom(): BlockNode {\n    const [, , , bottom] = this.root.children\n    return bottom as BlockNode\n  }\n\n  public get logo(): Logo | null {\n    return this.appLogo?.logo ?? null\n  }\n\n  public appRootWithLogo(logo: Logo, metadata: ForwardMsgMetadata): AppRoot {\n    const { activeScriptHash } = metadata\n    return new AppRoot(this.mainScriptHash, this.root, {\n      logo,\n      activeScriptHash,\n    })\n  }\n\n  public applyDelta(\n    scriptRunId: string,\n    delta: Delta,\n    metadata: ForwardMsgMetadata\n  ): AppRoot {\n    // The full path to the AppNode within the element tree.\n    // Used to find and update the element node specified by this Delta.\n    const { deltaPath, activeScriptHash } = metadata\n\n    switch (delta.type) {\n      case \"newElement\": {\n        const element = delta.newElement as Element\n        return this.addElement(\n          deltaPath,\n          scriptRunId,\n          element,\n          metadata,\n          activeScriptHash,\n          delta.fragmentId\n        )\n      }\n\n      case \"addBlock\": {\n        return this.addBlock(\n          deltaPath,\n          delta.addBlock as BlockProto,\n          scriptRunId,\n          activeScriptHash,\n          delta.fragmentId\n        )\n      }\n\n      case \"arrowAddRows\": {\n        try {\n          return this.arrowAddRows(\n            deltaPath,\n            delta.arrowAddRows as ArrowNamedDataSet,\n            scriptRunId\n          )\n        } catch (error) {\n          const errorElement = makeElementWithErrorText(\n            ensureError(error).message\n          )\n          return this.addElement(\n            deltaPath,\n            scriptRunId,\n            errorElement,\n            metadata,\n            activeScriptHash\n          )\n        }\n      }\n\n      default: {\n        throw new Error(`Unrecognized deltaType: '${delta.type}'`)\n      }\n    }\n  }\n\n  filterMainScriptElements(mainScriptHash: string): AppRoot {\n    // clears all nodes that are not associated with the mainScriptHash\n    // Get the current script run id from one of the children\n    const currentScriptRunId = this.main.scriptRunId\n    const main =\n      this.main.filterMainScriptElements(mainScriptHash) ||\n      new BlockNode(mainScriptHash)\n    const sidebar =\n      this.sidebar.filterMainScriptElements(mainScriptHash) ||\n      new BlockNode(mainScriptHash)\n    const event =\n      this.event.filterMainScriptElements(mainScriptHash) ||\n      new BlockNode(mainScriptHash)\n    const bottom =\n      this.bottom.filterMainScriptElements(mainScriptHash) ||\n      new BlockNode(mainScriptHash)\n    const appLogo =\n      this.appLogo?.activeScriptHash === mainScriptHash ? this.appLogo : null\n\n    return new AppRoot(\n      mainScriptHash,\n      new BlockNode(\n        mainScriptHash,\n        [main, sidebar, event, bottom],\n        new BlockProto({ allowEmpty: true }),\n        currentScriptRunId\n      ),\n      appLogo\n    )\n  }\n\n  public clearStaleNodes(\n    currentScriptRunId: string,\n    fragmentIdsThisRun?: Array<string>\n  ): AppRoot {\n    const main =\n      this.main.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||\n      new BlockNode(this.mainScriptHash)\n    const sidebar =\n      this.sidebar.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||\n      new BlockNode(this.mainScriptHash)\n    const event =\n      this.event.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||\n      new BlockNode(this.mainScriptHash)\n    const bottom =\n      this.bottom.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||\n      new BlockNode(this.mainScriptHash)\n\n    return new AppRoot(\n      this.mainScriptHash,\n      new BlockNode(\n        this.mainScriptHash,\n        [main, sidebar, event, bottom],\n        new BlockProto({ allowEmpty: true }),\n        currentScriptRunId\n      ),\n      this.appLogo\n    )\n  }\n\n  /** Return a Set containing all Elements in the tree. */\n  public getElements(): Set<Element> {\n    const elements = new Set<Element>()\n    this.main.getElements(elements)\n    this.sidebar.getElements(elements)\n    this.event.getElements(elements)\n    this.bottom.getElements(elements)\n    return elements\n  }\n\n  private addElement(\n    deltaPath: number[],\n    scriptRunId: string,\n    element: Element,\n    metadata: ForwardMsgMetadata,\n    activeScriptHash: string,\n    fragmentId?: string\n  ): AppRoot {\n    const elementNode = new ElementNode(\n      element,\n      metadata,\n      scriptRunId,\n      activeScriptHash,\n      fragmentId\n    )\n    return new AppRoot(\n      this.mainScriptHash,\n      this.root.setIn(deltaPath, elementNode, scriptRunId),\n      this.appLogo\n    )\n  }\n\n  private addBlock(\n    deltaPath: number[],\n    block: BlockProto,\n    scriptRunId: string,\n    activeScriptHash: string,\n    fragmentId?: string\n  ): AppRoot {\n    const existingNode = this.root.getIn(deltaPath)\n\n    // If we're replacing an existing Block, this new Block inherits\n    // the existing Block's children. This prevents existing widgets from\n    // having their values reset.\n    const children: AppNode[] =\n      existingNode instanceof BlockNode ? existingNode.children : []\n\n    const blockNode = new BlockNode(\n      activeScriptHash,\n      children,\n      block,\n      scriptRunId,\n      fragmentId\n    )\n    return new AppRoot(\n      this.mainScriptHash,\n      this.root.setIn(deltaPath, blockNode, scriptRunId),\n      this.appLogo\n    )\n  }\n\n  private arrowAddRows(\n    deltaPath: number[],\n    namedDataSet: ArrowNamedDataSet,\n    scriptRunId: string\n  ): AppRoot {\n    const existingNode = this.root.getIn(deltaPath) as ElementNode\n    if (existingNode == null) {\n      throw new Error(`Can't arrowAddRows: invalid deltaPath: ${deltaPath}`)\n    }\n\n    const elementNode = existingNode.arrowAddRows(namedDataSet, scriptRunId)\n    return new AppRoot(\n      this.mainScriptHash,\n      this.root.setIn(deltaPath, elementNode, scriptRunId),\n      this.appLogo\n    )\n  }\n}\n\n/** Iterates over datasets and converts data to Quiver. */\nfunction wrapDatasets(datasets: IArrowNamedDataSet[]): WrappedNamedDataset[] {\n  return datasets.map((dataset: IArrowNamedDataSet) => {\n    return {\n      hasName: dataset.hasName as boolean,\n      name: dataset.name as string,\n      data: new Quiver(dataset.data as IArrow),\n    }\n  })\n}\n"],"mappings":"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"}