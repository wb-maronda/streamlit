{"version":3,"file":"useScrollToBottom.js","names":["useCallback","useEffect","useRef","useScrollSpy","useScrollAnimation","useStateRef","DEFAULT_BOTTOM_THRESHOLD","SCROLL_DECISION_DURATION","MIN_CHECK_INTERVAL","setImmediateInterval","fn","ms","setInterval","isAtBottom","_ref","scrollHeight","offsetHeight","scrollTop","useScrollToBottom","scrollableRef","isSticky","setIsSticky","isStickyRef","isAnimating","setIsAnimating","isAnimatingRef","ignoreScrollEventBeforeRef","offsetHeightRef","scrollHeightRef","handleScrollToBottomFinished","current","Date","now","handleScroll","_ref2","timeStampLow","target","animating","atBottom","nextOffsetHeight","nextScrollHeight","offsetHeightChanged","scrollHeightChanged","nextSticky","stickyButNotAtEndSince","timeout","clearInterval","handleFocus","addEventListener","capture","passive","removeEventListener"],"sources":["../../src/hooks/useScrollToBottom.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RefObject, useCallback, useEffect, useRef } from \"react\"\n\nimport useScrollSpy from \"./useScrollSpy\"\nimport useScrollAnimation from \"./useScrollAnimation\"\nimport useStateRef from \"./useStateRef\"\n\nexport interface ScrollToBottomOptions {\n  bottomThreshold?: number\n  debounceMs?: number\n}\n\nconst DEFAULT_BOTTOM_THRESHOLD = 1\nconst SCROLL_DECISION_DURATION = 34 // 2 frames\nconst MIN_CHECK_INTERVAL = 17 // 1 frame\n\nfunction setImmediateInterval(fn: () => void, ms: number): NodeJS.Timeout {\n  fn()\n\n  return setInterval(fn, ms)\n}\n\nfunction isAtBottom({\n  scrollHeight,\n  offsetHeight,\n  scrollTop,\n}: HTMLElement): boolean {\n  return scrollHeight - scrollTop - offsetHeight < DEFAULT_BOTTOM_THRESHOLD\n}\n\n/**\n * useScrollToBottom is a custom React hook managing automatic\n * scrolling behavior for an HTML element. It keeps the scroll view\n * at the bottom unless a user scrolls up, then stops auto-scroll.\n *\n * This hook returns a ref object attached to the HTML element.\n * It maintains several pieces of state:\n * - isSticky: a boolean for whether the scroll position should\n *   \"stick\" to the bottom.\n * - isAnimating: a boolean for whether the scroll view is animating.\n *\n * It has two major functions:\n * - handleScrollToBottomFinished: resets stickiness if necessary.\n * - handleScroll: adjusts isSticky based on user scroll behavior.\n *\n * The hook includes side effects with the useEffect hook:\n * - The first effect sets an interval to check the scroll position\n *   and adjust stickiness and animating state.\n * - The second effect attaches a focus event listener to update\n *   the scrollHeight value.\n */\nexport function useScrollToBottom<T extends HTMLElement>(): RefObject<T> {\n  const scrollableRef = useRef<T>(null)\n  const [isSticky, setIsSticky, isStickyRef] = useStateRef(false)\n  const [isAnimating, setIsAnimating, isAnimatingRef] = useStateRef(true)\n\n  // Internal context\n  const ignoreScrollEventBeforeRef = useRef(0)\n  const offsetHeightRef = useRef(0)\n  const scrollHeightRef = useRef(0)\n\n  // Once, we have determined we are at the bottom, we can reset\n  // the ignoring of scroll events.\n  const handleScrollToBottomFinished = useCallback(() => {\n    ignoreScrollEventBeforeRef.current = Date.now()\n\n    // handleScrollToBottomFinished may end at a position which should lose stickiness.\n    // In that case, we will need to set sticky to false to stop the interval check.\n    if (!isAnimatingRef.current) {\n      // Essentially we are not suppose to be animating cause a scroll\n      // occurred before we finished animating.\n      setIsSticky(false)\n    }\n\n    setIsAnimating(false)\n  }, [ignoreScrollEventBeforeRef, isAnimatingRef, setIsAnimating, setIsSticky])\n\n  const handleScroll = useCallback(\n    ({ timeStampLow }: { timeStampLow: number }) => {\n      const { current: target } = scrollableRef\n      const animating = isAnimatingRef.current\n\n      // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n      // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n      if (timeStampLow <= ignoreScrollEventBeforeRef.current || !target) {\n        // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n        // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n\n        return\n      }\n\n      const atBottom = isAtBottom(target)\n\n      // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n      // We need to ignore these \"synthetic\" events\n      const {\n        offsetHeight: nextOffsetHeight,\n        scrollHeight: nextScrollHeight,\n      } = target\n      const { current: offsetHeight } = offsetHeightRef\n      const { current: scrollHeight } = scrollHeightRef\n      const offsetHeightChanged = nextOffsetHeight !== offsetHeight\n      const scrollHeightChanged = nextScrollHeight !== scrollHeight\n\n      if (offsetHeightChanged) {\n        offsetHeightRef.current = nextOffsetHeight\n      }\n\n      if (scrollHeightChanged) {\n        scrollHeightRef.current = nextScrollHeight\n      }\n\n      // Sticky means:\n      // - If it is scrolled programatically, we are still in sticky mode\n      // - If it is scrolled by the user, then sticky means if we are at the end\n\n      // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n      if (!offsetHeightChanged && !scrollHeightChanged) {\n        // We are sticky if we are animating to the end, or we are already at the end.\n        // We can be \"animating but not sticky\" by calling \"scrollTo(100)\" where the container scrollHeight is 200px.\n        const nextSticky = animating || atBottom\n\n        if (isStickyRef.current !== nextSticky) {\n          setIsSticky(nextSticky)\n        }\n      } else if (isStickyRef.current) {\n        setIsAnimating(true)\n        setIsSticky(true)\n      }\n    },\n    [\n      ignoreScrollEventBeforeRef,\n      offsetHeightRef,\n      scrollHeightRef,\n      isAnimatingRef,\n      isStickyRef,\n      setIsAnimating,\n      setIsSticky,\n    ]\n  )\n\n  useEffect(() => {\n    if (scrollableRef.current) {\n      let stickyButNotAtEndSince = 0\n\n      const timeout = setImmediateInterval(() => {\n        const { current: target } = scrollableRef\n        const animating = isAnimatingRef.current\n\n        if (isStickyRef.current && target) {\n          if (!isAtBottom(target)) {\n            if (!stickyButNotAtEndSince) {\n              stickyButNotAtEndSince = Date.now()\n            } else if (\n              Date.now() - stickyButNotAtEndSince >\n              SCROLL_DECISION_DURATION\n            ) {\n              // Quirks: In Firefox, after user scroll down, Firefox do two things:\n              //         1. Set to a new \"scrollTop\"\n              //         2. Fire \"scroll\" event\n              //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n              //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n              // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n\n              // The \"animating\" check will make sure stickiness is not lost when elements are adding at a very fast pace.\n              if (!animating) {\n                setIsAnimating(true)\n                setIsSticky(true)\n              }\n\n              stickyButNotAtEndSince = 0\n            }\n          } else {\n            stickyButNotAtEndSince = 0\n          }\n        } else if (\n          target &&\n          target.scrollHeight <= target.offsetHeight &&\n          !isStickyRef.current\n        ) {\n          // When the container is emptied, we will set sticky back to true.\n          setIsSticky(true)\n        }\n      }, MIN_CHECK_INTERVAL)\n\n      return () => clearInterval(timeout)\n    }\n  }, [\n    scrollableRef,\n    isSticky,\n    isAnimating,\n    isAnimatingRef,\n    isStickyRef,\n    setIsSticky,\n    setIsAnimating,\n  ])\n\n  useEffect(() => {\n    // We need to update the \"scrollHeight\" value to latest when the user do a focus inside the box.\n    //\n    // This is because:\n    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether \"scrollHeight\" value is latest or not.\n    // - That code only run on \"scroll\" event.\n    // - That means, on every \"scroll\" event, if the \"scrollHeight\" value is not latest, we will skip modifying the stickiness.\n    // - That means, if the user \"focus\" to an element that cause the scroll view to scroll to the bottom, the user agent will fire \"scroll\" event.\n    //   Since the \"scrollHeight\" is not latest value, this \"scroll\" event will be ignored and stickiness will not be modified.\n    // - That means, if the user \"focus\" to a newly added element that is at the end of the scroll view, the \"scroll to bottom\" button will continue to show.\n    const target = scrollableRef.current\n    if (target) {\n      const handleFocus = (): void => {\n        scrollHeightRef.current = target.scrollHeight\n      }\n\n      target.addEventListener(\"focus\", handleFocus, {\n        capture: true,\n        passive: true,\n      })\n\n      return () => target.removeEventListener(\"focus\", handleFocus)\n    }\n  }, [scrollableRef])\n\n  useScrollSpy(scrollableRef.current, handleScroll)\n  useScrollAnimation(\n    scrollableRef.current,\n    handleScrollToBottomFinished,\n    isAnimating\n  )\n\n  return scrollableRef\n}\n\nexport default useScrollToBottom\n"],"mappings":"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"}