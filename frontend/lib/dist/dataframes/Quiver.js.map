{"version":3,"file":"Quiver.js","names":["Vector","tableFromIPC","Null","Dictionary","Struct","util","immerable","produce","range","unzip","zip","trimEnd","moment","numbro","notNullOrUndefined","logWarning","WEEKDAY_SHORT","formatMs","duration","add","format","formatSec","formatMin","formatHours","formatDay","formatMonth","formatYear","formatWeeks","freqParam","Error","dayIndex","indexOf","concat","JSON","stringify","startDate","day","endDate","formatQuarter","endOf","PERIOD_TYPE_FORMATTERS","L","ms","S","s","T","min","H","h","D","M","W","Q","Y","A","IndexTypeName","DataFrameCellType","Quiver","constructor","element","_index","_columns","_indexNames","_data","_fields","_types","_styler","table","data","schema","parseSchema","rawColumns","getRawColumns","fields","parseFields","index","parseIndex","columns","parseColumns","indexNames","parseIndexNames","parseData","types","parseTypes","styler","parseStyler","undefined","metadata","get","parse","map","columnSchema","field_name","filter","columnName","index_columns","includes","indexName","isRangeIndex","start","stop","step","column","getChild","type","name","startsWith","isMultiIndex","column_indexes","length","fieldName","replace","numDataRows","numRows","numDataColumns","select","parseIndexType","parseDataType","pandas_type","RangeIndex","numpy_type","meta","indexColumn","find","getCategoricalOptions","dataColumnIndex","_this$_data$getChildA","_this$_data$getChildA2","dataColumns","dimensions","String","categoricalDict","getChildAt","dictionary","values","i","push","uuid","caption","styles","displayValues","concatIndexes","otherIndex","otherIndexTypes","sameIndexTypes","receivedIndexTypes","getTypeName","expectedIndexTypes","zipped","a","t1","t2","every","concatData","otherData","otherDataType","numCols","sameDataTypes","receivedDataTypes","t","expectedDataTypes","slicedOtherData","selectAt","_t2$index","concatTypes","otherTypes","concatIndexTypes","concatDataTypes","indexType","otherStart","otherStop","otherStep","otherRangeIndexLength","newStop","otherDataTypes","kind","formatIntervalType","typeName","match","subtype","closed","formatInterval","interval","toJSON","leftBracket","rightBracket","leftInterval","left","rightInterval","right","convertToSeconds","value","unit","unitAdjustment","Number","isSafeInteger","BigInt","formatTime","field","_field$type$unit","_field$type","timeInSeconds","unix","utc","formatDuration","_field$type$unit2","_field$type2","humanize","formatDecimal","scale","numString","bigNumToString","BN","padStart","sign","slice","wholePart","decimalPart","formatPeriodType","freq","formatPeriod","freqName","split","momentConverter","durationNumber","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","formatCategoricalType","x","extensionName","extensionMetadata","isDate","Date","isFinite","datetime","timezone","tz","zone","utcOffset","_field$type3","_key","cssId","_this$_styler","cssStyles","_this$_styler2","_this$_styler3","_this$_columns","_this$_columns$","headerColumns","headerRows","dataRows","rows","isEmpty","getCell","rowIndex","columnIndex","_this$_styler5","_this$_styler6","isBlankCell","isIndexCell","isColumnsCell","cssClass","BLANK","join","content","_this$_styler4","dataRowIndex","contentType","getIndexValue","INDEX","COLUMNS","UnicodeIndex","getDataValue","displayContent","DATA","_this$_data$getChildA3","addRows","other","draft","Object","fromEntries"],"sources":["../../src/dataframes/Quiver.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Private members use _.\n/* eslint-disable no-underscore-dangle */\n\nimport {\n  StructRow,\n  Table,\n  Vector,\n  tableFromIPC,\n  Null,\n  Field,\n  Dictionary,\n  Struct,\n  Schema as ArrowSchema,\n  util,\n} from \"apache-arrow\"\nimport { immerable, produce } from \"immer\"\nimport range from \"lodash/range\"\nimport unzip from \"lodash/unzip\"\nimport zip from \"lodash/zip\"\nimport trimEnd from \"lodash/trimEnd\"\nimport moment from \"moment-timezone\"\nimport numbro from \"numbro\"\n\nimport { IArrow, Styler as StylerProto } from \"@streamlit/lib/src/proto\"\nimport { notNullOrUndefined } from \"@streamlit/lib/src/util/utils\"\nimport { logWarning } from \"@streamlit/lib/src/util/log\"\n\n/** Data types used by ArrowJS. */\nexport type DataType =\n  | null\n  | boolean\n  | number\n  | string\n  | Date // datetime\n  | Int32Array // int\n  | Uint8Array // bytes\n  | Uint32Array // Decimal\n  | Vector // arrays\n  | StructRow // interval\n  | Dictionary // categorical\n  | Struct // dict\n  | bigint // period\n\n/**\n * A row-major grid of DataFrame index header values.\n */\ntype IndexValue = Vector | number[]\n\n/**\n * A row-major grid of DataFrame index header values.\n */\ntype Index = IndexValue[]\n\n/**\n * A row-major grid of DataFrame column header values.\n * NOTE: ArrowJS automatically formats the columns in schema, i.e. we always get strings.\n */\ntype Columns = string[][]\n\n/**\n * A row-major grid of DataFrame data.\n */\ntype Data = Table\n\n// This type should be recursive as there can be nested structures.\n// Example: list[int64], list[list[unicode]], etc.\n// NOTE: Commented out until we can find a way to properly define recursive types.\n//\n// enum DataTypeName {\n//   Empty = \"empty\",\n//   Boolean = \"bool\",\n//   Number = \"int64\",\n//   Float = \"float64\",\n//   String = \"unicode\",\n//   Date = \"date\", // \"datetime\", \"datetimetz\"\n//   Bytes = \"bytes\",\n//   Object = \"object\",\n//   List = \"list[int64]\",\n// }\n\n/** DataFrame index and data types. */\ninterface Types {\n  /** Types for each index column. */\n  index: Type[]\n\n  /** Types for each data column. */\n  // NOTE: `DataTypeName` should be used here, but as it's hard (maybe impossible)\n  // to define such recursive types in TS, `string` will suffice for now.\n  data: Type[]\n}\n\n/** Type information for single-index columns, and data columns. */\nexport interface Type {\n  /** The type label returned by pandas.api.types.infer_dtype */\n  // NOTE: `DataTypeName` should be used here, but as it's hard (maybe impossible)\n  // to define such recursive types in TS, `string` will suffice for now.\n  pandas_type: IndexTypeName | string\n\n  /** The numpy dtype that corresponds to the types returned in df.dtypes */\n  numpy_type: string\n\n  /** Type metadata. */\n  meta?: Record<string, any> | null\n}\n\ntype IntervalData = \"int64\" | \"uint64\" | \"float64\" | \"datetime64[ns]\"\ntype IntervalClosed = \"left\" | \"right\" | \"both\" | \"neither\"\ntype IntervalType = `interval[${IntervalData}, ${IntervalClosed}]`\n\n// The frequency strings defined in pandas.\n// See: https://pandas.pydata.org/docs/user_guide/timeseries.html#period-aliases\n// Not supported: \"N\" (nanoseconds), \"U\" & \"us\" (microseconds), and \"B\" (business days).\n// Reason is that these types are not supported by moment.js, but also they are not\n// very commonly used in practice.\ntype SupportedPandasOffsetType =\n  // yearly frequency:\n  | \"A\" // deprecated alias\n  | \"Y\"\n  // quarterly frequency:\n  | \"Q\"\n  // monthly frequency:\n  | \"M\"\n  // weekly frequency:\n  | \"W\"\n  // calendar day frequency:\n  | \"D\"\n  // hourly frequency:\n  | \"H\" // deprecated alias\n  | \"h\"\n  // minutely frequency\n  | \"T\" // deprecated alias\n  | \"min\"\n  // secondly frequency:\n  | \"S\" // deprecated alias\n  | \"s\"\n  // milliseconds frequency:\n  | \"L\" // deprecated alias\n  | \"ms\"\n\ntype PeriodFrequency =\n  | SupportedPandasOffsetType\n  | `${SupportedPandasOffsetType}-${string}`\ntype PeriodType = `period[${PeriodFrequency}]`\n\nconst WEEKDAY_SHORT = [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"]\nconst formatMs = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"ms\")\n    .format(\"YYYY-MM-DD HH:mm:ss.SSS\")\n\nconst formatSec = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"s\")\n    .format(\"YYYY-MM-DD HH:mm:ss\")\n\nconst formatMin = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"m\").format(\"YYYY-MM-DD HH:mm\")\n\nconst formatHours = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"h\").format(\"YYYY-MM-DD HH:mm\")\n\nconst formatDay = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"d\").format(\"YYYY-MM-DD\")\n\nconst formatMonth = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"M\").format(\"YYYY-MM\")\n\nconst formatYear = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"y\").format(\"YYYY\")\n\nconst formatWeeks = (duration: number, freqParam?: string): string => {\n  if (!freqParam) {\n    throw new Error('Frequency \"W\" requires parameter')\n  }\n  const dayIndex = WEEKDAY_SHORT.indexOf(freqParam)\n  if (dayIndex < 0) {\n    throw new Error(\n      `Invalid value: ${freqParam}. Supported values: ${JSON.stringify(\n        WEEKDAY_SHORT\n      )}`\n    )\n  }\n  const startDate = moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"w\")\n    .day(dayIndex - 6)\n    .format(\"YYYY-MM-DD\")\n  const endDate = moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"w\")\n    .day(dayIndex)\n    .format(\"YYYY-MM-DD\")\n\n  return `${startDate}/${endDate}`\n}\n\nconst formatQuarter = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"Q\")\n    .endOf(\"quarter\")\n    .format(\"YYYY[Q]Q\")\n\nconst PERIOD_TYPE_FORMATTERS: Record<\n  SupportedPandasOffsetType,\n  (duration: number, freqParam?: string) => string\n> = {\n  L: formatMs,\n  ms: formatMs,\n  S: formatSec,\n  s: formatSec,\n  T: formatMin,\n  min: formatMin,\n  H: formatHours,\n  h: formatHours,\n  D: formatDay,\n  M: formatMonth,\n  W: formatWeeks,\n  Q: formatQuarter,\n  Y: formatYear,\n  A: formatYear,\n}\n\n/** Interval data type. */\ninterface Interval {\n  left: number\n  right: number\n}\n\nexport enum IndexTypeName {\n  CategoricalIndex = \"categorical\",\n  DatetimeIndex = \"datetime\",\n  Float64Index = \"float64\",\n  Int64Index = \"int64\",\n  RangeIndex = \"range\",\n  UInt64Index = \"uint64\",\n  UnicodeIndex = \"unicode\",\n\n  // Throws an error.\n  TimedeltaIndex = \"time\",\n}\n\n/**\n * The Arrow table schema. It's a blueprint that tells us where data\n * is stored in the associated table. (Arrow stores the schema as a JSON string,\n * and we parse it into this typed object - so these member names come from\n * Arrow.)\n */\ninterface Schema {\n  /**\n   * The DataFrame's index names (either provided by user or generated,\n   * guaranteed unique). It is used to fetch the index data. Each DataFrame has\n   * at least 1 index. There are many different index types; for most of them\n   * the index name is stored as a string, but for the \"range\" index a `RangeIndex`\n   * object is used. A `RangeIndex` is only ever by itself, never as part of a\n   * multi-index. The length represents the dimensions of the DataFrame's index grid.\n   *\n   * Example:\n   * Range index: [{ kind: \"range\", name: null, start: 1, step: 1, stop: 5 }]\n   * Other index types: [\"__index_level_0__\", \"foo\", \"bar\"]\n   */\n  index_columns: (string | RangeIndex)[]\n\n  /**\n   * Schemas for each column (index *and* data columns) in the DataFrame.\n   */\n  columns: ColumnSchema[]\n\n  /**\n   * DataFrame column headers.\n   * The length represents the dimensions of the DataFrame's columns grid.\n   */\n  column_indexes: ColumnSchema[]\n}\n\n/** Metadata for the \"range\" index type. */\ninterface RangeIndex {\n  kind: \"range\"\n  name: string | null\n  start: number\n  step: number\n  stop: number\n}\n\n/**\n * Metadata for a single column in an Arrow table.\n * (This can describe an index *or* a data column.)\n */\ninterface ColumnSchema {\n  /**\n   * The fieldName of the column.\n   * For a single-index column, this is just the name of the column (e.g. \"foo\").\n   * For a multi-index column, this is a stringified tuple (e.g. \"('1','foo')\")\n   */\n  field_name: string\n\n  /**\n   * Column-specific metadata. Only used by certain column types\n   * (e.g. CategoricalIndex has `num_categories`.)\n   */\n  metadata: Record<string, any> | null\n\n  /** The name of the column. */\n  name: string | null\n\n  /**\n   * The type of the column. When `pandas_type == \"object\"`, `numpy_type`\n   * will have a more specific type.\n   */\n  pandas_type: string\n\n  /**\n   * When `pandas_type === \"object\"`, this field contains the object type.\n   * If pandas_type has another value, numpy_type is ignored.\n   */\n  numpy_type: string\n}\n\n/** DataFrame's Styler information. */\ninterface Styler {\n  /** Styler's UUID. */\n  uuid: string\n\n  /** Optional user-specified caption. */\n  caption: string | null\n\n  /** DataFrame's CSS styles. */\n  styles: string | null\n\n  /**\n   * Stringified versions of each cell in the DataFrame, in the\n   * user-specified format.\n   */\n  displayValues: Quiver\n}\n\n/** Dimensions of the DataFrame. */\ninterface DataFrameDimensions {\n  headerRows: number\n  headerColumns: number\n  dataRows: number\n  dataColumns: number\n  rows: number\n  columns: number\n}\n\n/**\n * There are 4 cell types:\n *  - blank, cells that are not part of index headers, column headers, or data\n *  - index, index header cells\n *  - columns, column header cells\n *  - data, data cells\n */\nexport enum DataFrameCellType {\n  BLANK = \"blank\",\n  INDEX = \"index\",\n  COLUMNS = \"columns\",\n  DATA = \"data\",\n}\n\n/** Data for a single cell in a DataFrame. */\nexport interface DataFrameCell {\n  /** The cell's type (blank, index, columns, or data). */\n  type: DataFrameCellType\n\n  /** The cell's CSS id, if the DataFrame has Styler. */\n  cssId?: string\n\n  /** The cell's CSS class. */\n  cssClass: string\n\n  /** The cell's content. */\n  content: DataType\n\n  /** The cell's content type. */\n  // For \"blank\" cells \"contentType\" is undefined.\n  contentType?: Type\n\n  /** The cell's field. */\n  field?: Field\n\n  /**\n   * The cell's formatted content string, if the DataFrame was created with a Styler.\n   * If the DataFrame is unstyled, displayContent will be undefined, and display\n   * code should apply a default formatting to the `content` value instead.\n   */\n  displayContent?: string\n}\n\n/**\n * Parses data from an Arrow table, and stores it in a row-major format\n * (which is more useful for our frontend display code than Arrow's columnar format).\n */\nexport class Quiver {\n  /**\n   * Plain objects (objects without a prototype), arrays, Maps and Sets are always drafted by Immer.\n   * Every other object must use the immerable symbol to mark itself as compatible with Immer.\n   * When one of these objects is mutated within a producer, its prototype is preserved between copies.\n   * Source: https://immerjs.github.io/immer/complex-objects/\n   */\n  [immerable] = true\n\n  /** DataFrame's index (matrix of row names). */\n  private _index: Index\n\n  /** DataFrame's column labels (matrix of column names). */\n  private _columns: Columns\n\n  /** DataFrame's index names. */\n  private _indexNames: string[]\n\n  /** DataFrame's data. */\n  private _data: Data\n\n  /** Definition for DataFrame's fields. */\n  private _fields: Record<string, Field<any>>\n\n  /** Types for DataFrame's index and data. */\n  private _types: Types\n\n  /** [optional] DataFrame's Styler data. This will be defined if the user styled the dataframe. */\n  private readonly _styler?: Styler\n\n  constructor(element: IArrow) {\n    const table = tableFromIPC(element.data)\n    const schema = Quiver.parseSchema(table)\n    const rawColumns = Quiver.getRawColumns(schema)\n    const fields = Quiver.parseFields(table.schema)\n\n    const index = Quiver.parseIndex(table, schema)\n    const columns = Quiver.parseColumns(schema)\n    const indexNames = Quiver.parseIndexNames(schema)\n    const data = Quiver.parseData(table, columns, rawColumns)\n    const types = Quiver.parseTypes(table, schema)\n    const styler = element.styler\n      ? Quiver.parseStyler(element.styler as StylerProto)\n      : undefined\n\n    // The assignment is done below to avoid partially populating the instance\n    // if an error is thrown.\n    this._index = index\n    this._columns = columns\n    this._data = data\n    this._types = types\n    this._fields = fields\n    this._styler = styler\n    this._indexNames = indexNames\n  }\n\n  /** Parse Arrow table's schema from a JSON string to an object. */\n  private static parseSchema(table: Table): Schema {\n    const schema = table.schema.metadata.get(\"pandas\")\n    if (schema == null) {\n      // This should never happen!\n      throw new Error(\"Table schema is missing.\")\n    }\n    return JSON.parse(schema)\n  }\n\n  /** Get unprocessed column names for data columns. Needed for selecting\n   * data columns when there are multi-columns. */\n  private static getRawColumns(schema: Schema): string[] {\n    return (\n      schema.columns\n        .map(columnSchema => columnSchema.field_name)\n        // Filter out all index columns\n        .filter(columnName => !schema.index_columns.includes(columnName))\n    )\n  }\n\n  /** Parse DataFrame's index header values. */\n  private static parseIndex(table: Table, schema: Schema): Index {\n    return schema.index_columns\n      .map(indexName => {\n        // Generate a range using the \"range\" index metadata.\n        if (Quiver.isRangeIndex(indexName)) {\n          const { start, stop, step } = indexName\n          return range(start, stop, step)\n        }\n\n        // Otherwise, use the index name to get the index column data.\n        const column = table.getChild(indexName as string)\n        if (column instanceof Vector && column.type instanceof Null) {\n          return null\n        }\n        return column\n      })\n      .filter(\n        (column: IndexValue | null): column is IndexValue => column !== null\n      )\n  }\n\n  /** Parse DataFrame's index header names. */\n  private static parseIndexNames(schema: Schema): string[] {\n    return schema.index_columns.map(indexName => {\n      // Range indices are treated differently since they\n      // contain additional metadata (e.g. start, stop, step).\n      // and not just the name.\n      if (Quiver.isRangeIndex(indexName)) {\n        const { name } = indexName\n        return name || \"\"\n      }\n      if (indexName.startsWith(\"__index_level_\")) {\n        // Unnamed indices can have a name like \"__index_level_0__\".\n        return \"\"\n      }\n      return indexName\n    })\n  }\n\n  /** Parse DataFrame's column header values. */\n  private static parseColumns(schema: Schema): Columns {\n    // If DataFrame `columns` has multi-level indexing, the length of\n    // `column_indexes` will show how many levels there are.\n    const isMultiIndex = schema.column_indexes.length > 1\n\n    // Perform the following transformation:\n    // [\"('1','foo')\", \"('2','bar')\", \"('3','baz')\"] -> ... -> [[\"1\", \"2\", \"3\"], [\"foo\", \"bar\", \"baz\"]]\n    return unzip(\n      schema.columns\n        .map(columnSchema => columnSchema.field_name)\n        // Filter out all index columns\n        .filter(fieldName => !schema.index_columns.includes(fieldName))\n        .map(fieldName =>\n          isMultiIndex\n            ? JSON.parse(\n                fieldName\n                  .replace(/\\(/g, \"[\")\n                  .replace(/\\)/g, \"]\")\n                  .replace(/'/g, '\"')\n              )\n            : [fieldName]\n        )\n    )\n  }\n\n  /** Parse DataFrame's data. */\n  private static parseData(\n    table: Table,\n    columns: Columns,\n    rawColumns: string[]\n  ): Data {\n    const numDataRows = table.numRows\n    const numDataColumns = columns.length > 0 ? columns[0].length : 0\n    if (numDataRows === 0 || numDataColumns === 0) {\n      return table.select([])\n    }\n\n    return table.select(rawColumns)\n  }\n\n  /** Parse DataFrame's index and data types. */\n  private static parseTypes(table: Table, schema: Schema): Types {\n    const index = Quiver.parseIndexType(schema)\n    const data = Quiver.parseDataType(table, schema)\n    return { index, data }\n  }\n\n  /** Parse types for each index column. */\n  private static parseIndexType(schema: Schema): Type[] {\n    return schema.index_columns.map(indexName => {\n      if (Quiver.isRangeIndex(indexName)) {\n        return {\n          pandas_type: IndexTypeName.RangeIndex,\n          numpy_type: IndexTypeName.RangeIndex,\n          meta: indexName as RangeIndex,\n        }\n      }\n\n      // Find the index column we're looking for in the schema.\n      const indexColumn = schema.columns.find(\n        column => column.field_name === indexName\n      )\n\n      // This should never happen!\n      if (!indexColumn) {\n        throw new Error(`${indexName} index not found.`)\n      }\n\n      return {\n        pandas_type: indexColumn.pandas_type,\n        numpy_type: indexColumn.numpy_type,\n        meta: indexColumn.metadata,\n      }\n    })\n  }\n\n  /**\n   * Returns the categorical options defined for a given data column.\n   * Returns undefined if the column is not categorical.\n   *\n   * This function only works for non-index columns and expects the index at 0\n   * for the first non-index data column.\n   */\n  public getCategoricalOptions(dataColumnIndex: number): string[] | undefined {\n    const { dataColumns: numDataColumns } = this.dimensions\n\n    if (dataColumnIndex < 0 || dataColumnIndex >= numDataColumns) {\n      throw new Error(`Column index is out of range: ${dataColumnIndex}`)\n    }\n\n    if (!(this._fields[String(dataColumnIndex)].type instanceof Dictionary)) {\n      // This is not a categorical column\n      return undefined\n    }\n\n    const categoricalDict =\n      this._data.getChildAt(dataColumnIndex)?.data[0]?.dictionary\n    if (categoricalDict) {\n      // get all values into a list\n      const values = []\n\n      for (let i = 0; i < categoricalDict.length; i++) {\n        values.push(categoricalDict.get(i))\n      }\n      return values\n    }\n    return undefined\n  }\n\n  /** Parse types for each non-index column. */\n  private static parseDataType(table: Table, schema: Schema): Type[] {\n    return (\n      schema.columns\n        // Filter out all index columns\n        .filter(\n          columnSchema =>\n            !schema.index_columns.includes(columnSchema.field_name)\n        )\n        .map(columnSchema => ({\n          pandas_type: columnSchema.pandas_type,\n          numpy_type: columnSchema.numpy_type,\n          meta: columnSchema.metadata,\n        }))\n    )\n  }\n\n  /** Parse styler information from proto. */\n  private static parseStyler(styler: StylerProto): Styler {\n    return {\n      uuid: styler.uuid,\n      caption: styler.caption,\n      styles: styler.styles,\n\n      // Recursively create a new Quiver instance for Styler's display values.\n      // This values will be used for rendering the DataFrame, while the original values\n      // will be used for sorting, etc.\n      displayValues: new Quiver({ data: styler.displayValues }),\n    }\n  }\n\n  /** Concatenate the original DataFrame index with the given one. */\n  private concatIndexes(otherIndex: Index, otherIndexTypes: Type[]): Index {\n    // If one of the `index` arrays is empty, return the other one.\n    // Otherwise, they will have different types and an error will be thrown.\n    if (otherIndex.length === 0) {\n      return this._index\n    }\n    if (this._index.length === 0) {\n      return otherIndex\n    }\n\n    // Make sure indexes have same types.\n    if (!Quiver.sameIndexTypes(this._types.index, otherIndexTypes)) {\n      const receivedIndexTypes = otherIndexTypes.map(index =>\n        Quiver.getTypeName(index)\n      )\n      const expectedIndexTypes = this._types.index.map(index =>\n        Quiver.getTypeName(index)\n      )\n\n      throw new Error(`\nUnsupported operation. The data passed into \\`add_rows()\\` must have the same\nindex signature as the original data.\n\nIn this case, \\`add_rows()\\` received \\`${JSON.stringify(receivedIndexTypes)}\\`\nbut was expecting \\`${JSON.stringify(expectedIndexTypes)}\\`.\n`)\n    }\n\n    if (this._types.index.length === 0) {\n      // This should never happen!\n      throw new Error(\"There was an error while parsing index types.\")\n    }\n\n    // NOTE: \"range\" index cannot be a part of a multi-index, i.e.\n    // if the index type is \"range\", there will only be one element in the index array.\n    if (this._types.index[0].pandas_type === IndexTypeName.RangeIndex) {\n      // Continue the sequence for a \"range\" index.\n      // NOTE: The metadata of the original index will be used, i.e.\n      // if both indexes are of type \"range\" and they have different\n      // metadata (start, step, stop) values, the metadata of the given\n      // index will be ignored.\n      const { step, stop } = this._types.index[0].meta as RangeIndex\n      otherIndex = [\n        range(\n          stop,\n          // End is not inclusive\n          stop + otherIndex[0].length * step,\n          step\n        ),\n      ]\n    }\n\n    // Concatenate each index with its counterpart in the other table\n    const zipped = zip(this._index, otherIndex)\n    // @ts-expect-error We know the two indexes are of the same size\n    return zipped.map(a => a[0].concat(a[1]))\n  }\n\n  /** True if both arrays contain the same index types in the same order. */\n  private static sameIndexTypes(t1: Type[], t2: Type[]): boolean {\n    // Make sure both indexes have same dimensions.\n    if (t1.length !== t2.length) {\n      return false\n    }\n\n    return t1.every(\n      (type: Type, index: number) =>\n        index < t2.length &&\n        Quiver.getTypeName(type) === Quiver.getTypeName(t2[index])\n    )\n  }\n\n  /** Concatenate the original DataFrame data with the given one. */\n  private concatData(otherData: Data, otherDataType: Type[]): Data {\n    // If one of the `data` arrays is empty, return the other one.\n    // Otherwise, they will have different types and an error will be thrown.\n    if (otherData.numCols === 0) {\n      return this._data\n    }\n    if (this._data.numCols === 0) {\n      return otherData\n    }\n\n    // Make sure `data` arrays have the same types.\n    if (!Quiver.sameDataTypes(this._types.data, otherDataType)) {\n      const receivedDataTypes = otherDataType.map(t => t.pandas_type)\n      const expectedDataTypes = this._types.data.map(t => t.pandas_type)\n\n      throw new Error(`\nUnsupported operation. The data passed into \\`add_rows()\\` must have the same\ndata signature as the original data.\n\nIn this case, \\`add_rows()\\` received \\`${JSON.stringify(receivedDataTypes)}\\`\nbut was expecting \\`${JSON.stringify(expectedDataTypes)}\\`.\n`)\n    }\n\n    // Remove extra columns from the \"other\" DataFrame.\n    // Columns from otherData are used by index without checking column names.\n    const slicedOtherData = otherData.selectAt(range(0, this._data.numCols))\n    return this._data.concat(slicedOtherData)\n  }\n\n  /** True if both arrays contain the same data types in the same order. */\n  private static sameDataTypes(t1: Type[], t2: Type[]): boolean {\n    // NOTE: We remove extra columns from the DataFrame that we add rows from.\n    // Thus, as long as the length of `t2` is >= than `t1`, this will work properly.\n    // For columns, `pandas_type` will point us to the correct type.\n    return t1.every(\n      (type: Type, index: number) =>\n        type.pandas_type === t2[index]?.pandas_type\n    )\n  }\n\n  /** Concatenate index and data types. */\n  private concatTypes(otherTypes: Types): Types {\n    const index = this.concatIndexTypes(otherTypes.index)\n    const data = this.concatDataTypes(otherTypes.data)\n    return { index, data }\n  }\n\n  /** Concatenate index types. */\n  private concatIndexTypes(otherIndexTypes: Type[]): Type[] {\n    // If one of the `types` arrays is empty, return the other one.\n    // Otherwise, an empty array will be returned.\n    if (otherIndexTypes.length === 0) {\n      return this._types.index\n    }\n    if (this._types.index.length === 0) {\n      return otherIndexTypes\n    }\n\n    // Make sure indexes have same types.\n    if (!Quiver.sameIndexTypes(this._types.index, otherIndexTypes)) {\n      const receivedIndexTypes = otherIndexTypes.map(index =>\n        Quiver.getTypeName(index)\n      )\n      const expectedIndexTypes = this._types.index.map(index =>\n        Quiver.getTypeName(index)\n      )\n\n      throw new Error(`\nUnsupported operation. The data passed into \\`add_rows()\\` must have the same\nindex signature as the original data.\n\nIn this case, \\`add_rows()\\` received \\`${JSON.stringify(receivedIndexTypes)}\\`\nbut was expecting \\`${JSON.stringify(expectedIndexTypes)}\\`.\n`)\n    }\n\n    // TL;DR This sets the new stop value.\n    return this._types.index.map(indexType => {\n      // NOTE: \"range\" index cannot be a part of a multi-index, i.e.\n      // if the index type is \"range\", there will only be one element in the index array.\n      if (indexType.pandas_type === IndexTypeName.RangeIndex) {\n        const { stop, step } = indexType.meta as RangeIndex\n        const {\n          start: otherStart,\n          stop: otherStop,\n          step: otherStep,\n        } = otherIndexTypes[0].meta as RangeIndex\n        const otherRangeIndexLength = (otherStop - otherStart) / otherStep\n        const newStop = stop + otherRangeIndexLength * step\n        return {\n          ...indexType,\n          meta: {\n            ...indexType.meta,\n            stop: newStop,\n          },\n        }\n      }\n      return indexType\n    })\n  }\n\n  /** Concatenate types of data columns. */\n  private concatDataTypes(otherDataTypes: Type[]): Type[] {\n    if (this._types.data.length === 0) {\n      return otherDataTypes\n    }\n\n    return this._types.data\n  }\n\n  /** True if the index name represents a \"range\" index. */\n  private static isRangeIndex(\n    indexName: string | RangeIndex\n  ): indexName is RangeIndex {\n    return typeof indexName === \"object\" && indexName.kind === \"range\"\n  }\n\n  /** Formats an interval index. */\n  private static formatIntervalType(\n    data: StructRow,\n    typeName: IntervalType\n  ): string {\n    const match = typeName.match(/interval\\[(.+), (both|left|right|neither)\\]/)\n    if (match === null) {\n      throw new Error(`Invalid interval type: ${typeName}`)\n    }\n    const [, subtype, closed] = match\n    return this.formatInterval(data, subtype, closed as IntervalClosed)\n  }\n\n  private static formatInterval(\n    data: StructRow,\n    subtype: string,\n    closed: IntervalClosed\n  ): string {\n    const interval = data.toJSON() as Interval\n\n    const leftBracket = closed === \"both\" || closed === \"left\" ? \"[\" : \"(\"\n    const rightBracket = closed === \"both\" || closed === \"right\" ? \"]\" : \")\"\n    const leftInterval = Quiver.format(interval.left, {\n      pandas_type: subtype,\n      numpy_type: subtype,\n    })\n    const rightInterval = Quiver.format(interval.right, {\n      pandas_type: subtype,\n      numpy_type: subtype,\n    })\n\n    return `${leftBracket + leftInterval}, ${rightInterval + rightBracket}`\n  }\n\n  /**\n   * Adjusts a time value to seconds based on the unit information in the field.\n   *\n   * The unit numbers are specified here:\n   * https://github.com/apache/arrow/blob/3ab246f374c17a216d86edcfff7ff416b3cff803/js/src/enum.ts#L95\n   */\n  public static convertToSeconds(\n    value: number | bigint,\n    unit: number\n  ): number {\n    let unitAdjustment\n\n    if (unit === 1) {\n      // Milliseconds\n      unitAdjustment = 1000\n    } else if (unit === 2) {\n      // Microseconds\n      unitAdjustment = 1000 * 1000\n    } else if (unit === 3) {\n      // Nanoseconds\n      unitAdjustment = 1000 * 1000 * 1000\n    } else {\n      // Interpret it as seconds as a fallback\n      return Number(value)\n    }\n\n    // Do the calculation based on bigints, if the value\n    // is a bigint and not safe for usage as number.\n    // This might lose some precision since it doesn't keep\n    // fractional parts.\n    if (typeof value === \"bigint\" && !Number.isSafeInteger(Number(value))) {\n      return Number(value / BigInt(unitAdjustment))\n    }\n\n    return Number(value) / unitAdjustment\n  }\n\n  private static formatTime(data: number, field?: Field): string {\n    const timeInSeconds = Quiver.convertToSeconds(data, field?.type?.unit ?? 0)\n    return moment\n      .unix(timeInSeconds)\n      .utc()\n      .format(timeInSeconds % 1 === 0 ? \"HH:mm:ss\" : \"HH:mm:ss.SSS\")\n  }\n\n  private static formatDuration(data: number | bigint, field?: Field): string {\n    return moment\n      .duration(\n        Quiver.convertToSeconds(data, field?.type?.unit ?? 3),\n        \"seconds\"\n      )\n      .humanize()\n  }\n\n  /**\n   * Formats a decimal value with a given scale to a string.\n   *\n   * This code is partly based on: https://github.com/apache/arrow/issues/35745\n   *\n   * TODO: This is only a temporary workaround until ArrowJS can format decimals correctly.\n   * This is tracked here:\n   * https://github.com/apache/arrow/issues/37920\n   * https://github.com/apache/arrow/issues/28804\n   * https://github.com/apache/arrow/issues/35745\n   */\n  private static formatDecimal(value: Uint32Array, scale: number): string {\n    // Format Uint32Array to a numerical string and pad it with zeros\n    // So that it is exactly the length of the scale.\n    let numString = util\n      .bigNumToString(new util.BN(value))\n      .padStart(scale, \"0\")\n\n    // ArrowJS 13 correctly adds a minus sign for negative numbers.\n    // but it doesn't handle th fractional part yet. So we can just return\n    // the value if scale === 0, but we need to do some additional processing\n    // for the fractional part if scale > 0.\n\n    if (scale === 0) {\n      return numString\n    }\n\n    let sign = \"\"\n    if (numString.startsWith(\"-\")) {\n      // Check if number is negative, and if so remember the sign and remove it.\n      // We will add it back later.\n      sign = \"-\"\n      numString = numString.slice(1)\n    }\n    // Extract the whole number part. If the number is < 1, it doesn't\n    // have a whole number part, so we'll use \"0\" instead.\n    // E.g for 123450 with scale 3, we'll get \"123\" as the whole part.\n    const wholePart = numString.slice(0, -scale) || \"0\"\n    // Extract the fractional part and remove trailing zeros.\n    // E.g. for 123450 with scale 3, we'll get \"45\" as the fractional part.\n    const decimalPart = trimEnd(numString.slice(-scale), \"0\") || \"\"\n    // Combine the parts and add the sign.\n    return `${sign}${wholePart}` + (decimalPart ? `.${decimalPart}` : \"\")\n  }\n\n  public static formatPeriodType(\n    duration: bigint,\n    typeName: PeriodType\n  ): string {\n    const match = typeName.match(/period\\[(.*)]/)\n    if (match === null) {\n      logWarning(`Invalid period type: ${typeName}`)\n      return String(duration)\n    }\n    const [, freq] = match\n    return this.formatPeriod(duration, freq as PeriodFrequency)\n  }\n\n  private static formatPeriod(\n    duration: bigint,\n    freq: PeriodFrequency\n  ): string {\n    const [freqName, freqParam] = freq.split(\"-\", 2)\n    const momentConverter =\n      PERIOD_TYPE_FORMATTERS[freqName as SupportedPandasOffsetType]\n    if (!momentConverter) {\n      logWarning(`Unsupported period frequency: ${freq}`)\n      return String(duration)\n    }\n    const durationNumber = Number(duration)\n    if (!Number.isSafeInteger(durationNumber)) {\n      logWarning(\n        `Unsupported value: ${duration}. Supported values: [${Number.MIN_SAFE_INTEGER}-${Number.MAX_SAFE_INTEGER}]`\n      )\n      return String(duration)\n    }\n    return momentConverter(durationNumber, freqParam)\n  }\n\n  private static formatCategoricalType(\n    x: number | bigint | StructRow,\n    field: Field\n  ): string {\n    // Serialization for pandas.Interval and pandas.Period is provided by Arrow extensions\n    // https://github.com/pandas-dev/pandas/blob/235d9009b571c21b353ab215e1e675b1924ae55c/\n    // pandas/core/arrays/arrow/extension_types.py#L17\n    const extensionName = field.metadata.get(\"ARROW:extension:name\")\n    if (extensionName) {\n      const extensionMetadata = JSON.parse(\n        field.metadata.get(\"ARROW:extension:metadata\") as string\n      )\n      if (extensionName === \"pandas.interval\") {\n        const { subtype, closed } = extensionMetadata\n        return Quiver.formatInterval(x as StructRow, subtype, closed)\n      }\n      if (extensionName === \"pandas.Period\") {\n        const { freq } = extensionMetadata\n        return Quiver.formatPeriod(x as bigint, freq)\n      }\n    }\n    return String(x)\n  }\n\n  /** Returns type for a single-index column or data column. */\n  public static getTypeName(type: Type): IndexTypeName | string {\n    // For `PeriodType` and `IntervalType` types are kept in `numpy_type`,\n    // for the rest of the indexes in `pandas_type`.\n    return type.pandas_type === \"object\" ? type.numpy_type : type.pandas_type\n  }\n\n  /** Takes the data and it's type and nicely formats it. */\n  public static format(x: DataType, type?: Type, field?: Field): string {\n    const typeName = type && Quiver.getTypeName(type)\n\n    if (x == null) {\n      return \"<NA>\"\n    }\n\n    // date\n    const isDate = x instanceof Date || Number.isFinite(x)\n    if (isDate && typeName === \"date\") {\n      return moment.utc(x as Date | number).format(\"YYYY-MM-DD\")\n    }\n    // time\n    if (typeof x === \"bigint\" && typeName === \"time\") {\n      return Quiver.formatTime(Number(x), field)\n    }\n\n    // datetimetz\n    if (isDate && typeName === \"datetimetz\") {\n      const meta = type?.meta\n      let datetime = moment(x as Date | number)\n\n      if (meta?.timezone) {\n        if (moment.tz.zone(meta?.timezone)) {\n          // uses timezone notation\n          datetime = datetime.tz(meta?.timezone)\n        } else {\n          // uses UTC offset notation\n          datetime = datetime.utcOffset(meta?.timezone)\n        }\n      }\n\n      return datetime.format(\"YYYY-MM-DD HH:mm:ssZ\")\n    }\n    // datetime, datetime64, datetime64[ns], etc.\n    if (isDate && typeName?.startsWith(\"datetime\")) {\n      return moment.utc(x as Date | number).format(\"YYYY-MM-DD HH:mm:ss\")\n    }\n\n    if (typeName?.startsWith(\"interval\")) {\n      return Quiver.formatIntervalType(\n        x as StructRow,\n        typeName as IntervalType\n      )\n    }\n\n    if (typeName?.startsWith(\"period\")) {\n      return Quiver.formatPeriodType(x as bigint, typeName as PeriodType)\n    }\n\n    if (typeName === \"categorical\") {\n      return this.formatCategoricalType(\n        x as number | bigint | StructRow,\n        field as Field\n      )\n    }\n\n    if (typeName?.startsWith(\"timedelta\")) {\n      return this.formatDuration(x as number | bigint, field)\n    }\n\n    if (typeName === \"decimal\") {\n      return this.formatDecimal(x as Uint32Array, field?.type?.scale || 0)\n    }\n\n    // Nested arrays and objects.\n    if (typeName === \"object\" || typeName?.startsWith(\"list\")) {\n      if (field?.type instanceof Struct) {\n        // This type is used by python dictionary values\n\n        // Workaround: Arrow JS adds all properties from all cells\n        // as fields. When you convert to string, it will contain lots of fields with\n        // null values. To mitigate this, we filter out null values.\n\n        return JSON.stringify(x, (_key, value) => {\n          if (!notNullOrUndefined(value)) {\n            // Ignore null and undefined values ->\n            return undefined\n          }\n          if (typeof value === \"bigint\") {\n            return Number(value)\n          }\n          return value\n        })\n      }\n      return JSON.stringify(x, (_key, value) =>\n        typeof value === \"bigint\" ? Number(value) : value\n      )\n    }\n\n    if (typeName === \"float64\" && Number.isFinite(x)) {\n      return numbro(x).format(\"0,0.0000\")\n    }\n\n    return String(x)\n  }\n\n  /** DataFrame's index (matrix of row names). */\n  public get index(): Index {\n    return this._index\n  }\n\n  /** DataFrame's index names. */\n  public get indexNames(): string[] {\n    return this._indexNames\n  }\n\n  /** DataFrame's column labels (matrix of column names). */\n  public get columns(): Columns {\n    return this._columns\n  }\n\n  /** DataFrame's data. */\n  public get data(): Data {\n    return this._data\n  }\n\n  /** Types for DataFrame's index and data. */\n  public get types(): Types {\n    return this._types\n  }\n\n  /**\n   * The DataFrame's CSS id, if it has one.\n   *\n   * If the DataFrame has a Styler, the  CSS id is `T_${StylerUUID}`. Otherwise,\n   * it's undefined.\n   *\n   * This id is used by styled tables and styled dataframes to associate\n   * the Styler CSS with the styled data.\n   */\n  public get cssId(): string | undefined {\n    if (this._styler?.uuid == null) {\n      return undefined\n    }\n\n    return `T_${this._styler.uuid}`\n  }\n\n  /** The DataFrame's CSS styles, if it has a Styler. */\n  public get cssStyles(): string | undefined {\n    return this._styler?.styles || undefined\n  }\n\n  /** The DataFrame's caption, if it's been set. */\n  public get caption(): string | undefined {\n    return this._styler?.caption || undefined\n  }\n\n  /** The DataFrame's dimensions. */\n  public get dimensions(): DataFrameDimensions {\n    const headerColumns = this._index.length || this.types.index.length || 1\n    const headerRows = this._columns.length || 1\n    const dataRows = this._data.numRows || 0\n    const dataColumns = this._data.numCols || this._columns?.[0]?.length || 0\n\n    const rows = headerRows + dataRows\n    const columns = headerColumns + dataColumns\n\n    return {\n      headerRows,\n      headerColumns,\n      dataRows,\n      dataColumns,\n      rows,\n      columns,\n    }\n  }\n\n  /** True if the DataFrame has no index, columns, and data. */\n  public isEmpty(): boolean {\n    return (\n      this._index.length === 0 &&\n      this._columns.length === 0 &&\n      this._data.numRows === 0 &&\n      this._data.numCols === 0\n    )\n  }\n\n  /** Return a single cell in the table. */\n  public getCell(rowIndex: number, columnIndex: number): DataFrameCell {\n    const { headerRows, headerColumns, rows, columns } = this.dimensions\n\n    if (rowIndex < 0 || rowIndex >= rows) {\n      throw new Error(`Row index is out of range: ${rowIndex}`)\n    }\n    if (columnIndex < 0 || columnIndex >= columns) {\n      throw new Error(`Column index is out of range: ${columnIndex}`)\n    }\n\n    const isBlankCell = rowIndex < headerRows && columnIndex < headerColumns\n    const isIndexCell = rowIndex >= headerRows && columnIndex < headerColumns\n    const isColumnsCell = rowIndex < headerRows && columnIndex >= headerColumns\n\n    if (isBlankCell) {\n      // Blank cells include `blank`.\n      const cssClass = [\"blank\"]\n      if (columnIndex > 0) {\n        cssClass.push(`level${rowIndex}`)\n      }\n\n      return {\n        type: DataFrameCellType.BLANK,\n        cssClass: cssClass.join(\" \"),\n        content: \"\",\n      }\n    }\n\n    if (isIndexCell) {\n      const dataRowIndex = rowIndex - headerRows\n\n      const cssId = this._styler?.uuid\n        ? `${this.cssId}level${columnIndex}_row${dataRowIndex}`\n        : undefined\n\n      // Index label cells include:\n      // - row_heading\n      // - row<n> where n is the numeric position of the row\n      // - level<k> where k is the level in a MultiIndex\n      const cssClass = [\n        `row_heading`,\n        `level${columnIndex}`,\n        `row${dataRowIndex}`,\n      ].join(\" \")\n\n      const contentType = this._types.index[columnIndex]\n      const content = this.getIndexValue(dataRowIndex, columnIndex)\n      let field = this._fields[`__index_level_${String(columnIndex)}__`]\n      if (field === undefined) {\n        // If the index column has a name, we need to get it differently:\n        field = this._fields[String(columns - headerColumns)]\n      }\n      return {\n        type: DataFrameCellType.INDEX,\n        cssId,\n        cssClass,\n        content,\n        contentType,\n        field,\n      }\n    }\n\n    if (isColumnsCell) {\n      const dataColumnIndex = columnIndex - headerColumns\n\n      // Column label cells include:\n      // - col_heading\n      // - col<n> where n is the numeric position of the column\n      // - level<k> where k is the level in a MultiIndex\n      const cssClass = [\n        `col_heading`,\n        `level${rowIndex}`,\n        `col${dataColumnIndex}`,\n      ].join(\" \")\n\n      return {\n        type: DataFrameCellType.COLUMNS,\n        cssClass,\n        content: this._columns[rowIndex][dataColumnIndex],\n        // ArrowJS automatically converts \"columns\" cells to strings.\n        // Keep ArrowJS structure for consistency.\n        contentType: {\n          pandas_type: IndexTypeName.UnicodeIndex,\n          numpy_type: \"object\",\n        },\n      }\n    }\n\n    const dataRowIndex = rowIndex - headerRows\n    const dataColumnIndex = columnIndex - headerColumns\n\n    const cssId = this._styler?.uuid\n      ? `${this.cssId}row${dataRowIndex}_col${dataColumnIndex}`\n      : undefined\n\n    // Data cells include `data`.\n    const cssClass = [\n      \"data\",\n      `row${dataRowIndex}`,\n      `col${dataColumnIndex}`,\n    ].join(\" \")\n\n    const contentType = this._types.data[dataColumnIndex]\n    const field = this._fields[String(dataColumnIndex)]\n    const content = this.getDataValue(dataRowIndex, dataColumnIndex)\n    const displayContent = this._styler?.displayValues\n      ? (this._styler.displayValues.getCell(rowIndex, columnIndex)\n          .content as string)\n      : undefined\n\n    return {\n      type: DataFrameCellType.DATA,\n      cssId,\n      cssClass,\n      content,\n      contentType,\n      displayContent,\n      field,\n    }\n  }\n\n  public getIndexValue(rowIndex: number, columnIndex: number): any {\n    const index = this._index[columnIndex]\n    const value =\n      index instanceof Vector ? index.get(rowIndex) : index[rowIndex]\n    return value\n  }\n\n  public getDataValue(rowIndex: number, columnIndex: number): any {\n    return this._data.getChildAt(columnIndex)?.get(rowIndex)\n  }\n\n  /**\n   * Add the contents of another table (data + indexes) to this table.\n   * Extra columns will not be created.\n   */\n  public addRows(other: Quiver): Quiver {\n    if (this._styler || other._styler) {\n      throw new Error(`\nUnsupported operation. \\`add_rows()\\` does not support Pandas Styler objects.\n\nIf you do not need the Styler's styles, try passing the \\`.data\\` attribute of\nthe Styler object instead to concatenate just the underlying dataframe.\n\nFor example:\n\\`\\`\\`\nst.add_rows(my_styler.data)\n\\`\\`\\`\n`)\n    }\n\n    // Don't do anything if the incoming DataFrame is empty.\n    if (other.isEmpty()) {\n      return produce(this, (draft: Quiver) => draft)\n    }\n\n    // We need to handle this separately, as columns need to be reassigned.\n    // We don't concatenate columns in the general case.\n    if (this.isEmpty()) {\n      return produce(other, (draft: Quiver) => draft)\n    }\n\n    // Concatenate all data into temporary variables. If any of\n    // these operations fail, an error will be thrown and we'll prematurely\n    // exit the function.\n    const index = this.concatIndexes(other._index, other._types.index)\n    const data = this.concatData(other._data, other._types.data)\n    const types = this.concatTypes(other._types)\n\n    // If we get here, then we had no concatenation errors.\n    return produce(this, (draft: Quiver) => {\n      draft._index = index\n      draft._data = data\n      draft._types = types\n    })\n  }\n\n  private static parseFields(schema: ArrowSchema): Record<string, Field> {\n    // None-index data columns are listed first, and all index columns listed last\n    // within the fields array in arrow.\n    return Object.fromEntries(\n      (schema.fields || []).map((field, index) => [\n        field.name.startsWith(\"__index_level_\") ? field.name : String(index),\n        field,\n      ])\n    )\n  }\n}\n"],"mappings":"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"}