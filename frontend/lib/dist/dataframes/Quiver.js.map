{"version":3,"file":"Quiver.js","names":["Dictionary","Null","Struct","tableFromIPC","util","Vector","immerable","produce","range","unzip","zip","trimEnd","moment","numbro","isNullOrUndefined","notNullOrUndefined","logWarning","WEEKDAY_SHORT","formatMs","duration","add","format","formatSec","formatMin","formatHours","formatDay","formatMonth","formatYear","formatWeeks","freqParam","Error","dayIndex","indexOf","JSON","stringify","startDate","day","endDate","formatQuarter","endOf","PERIOD_TYPE_FORMATTERS","L","ms","S","s","T","min","H","h","D","M","W","Q","Y","A","IndexTypeName","DataFrameCellType","Quiver","constructor","element","_index","_columns","_indexNames","_data","_fields","_types","_styler","table","data","schema","parseSchema","rawColumns","getRawColumns","fields","parseFields","index","parseIndex","columns","parseColumns","indexNames","parseIndexNames","parseData","types","parseTypes","styler","parseStyler","undefined","metadata","get","parse","map","columnSchema","field_name","filter","columnName","index_columns","includes","indexName","isRangeIndex","start","stop","step","column","getChild","type","name","startsWith","isMultiIndex","column_indexes","length","fieldName","replace","numDataRows","numRows","numDataColumns","select","parseIndexType","parseDataType","pandas_type","RangeIndex","numpy_type","meta","indexColumn","find","getCategoricalOptions","dataColumnIndex","dataColumns","dimensions","String","categoricalDict","getChildAt","dictionary","values","i","push","uuid","caption","styles","displayValues","concatIndexes","otherIndex","otherIndexTypes","sameIndexTypes","receivedIndexTypes","getTypeName","expectedIndexTypes","zipped","a","concat","t1","t2","every","concatData","otherData","otherDataType","numCols","sameDataTypes","receivedDataTypes","t","expectedDataTypes","slicedOtherData","selectAt","concatTypes","otherTypes","concatIndexTypes","concatDataTypes","indexType","otherStart","otherStop","otherStep","otherRangeIndexLength","newStop","otherDataTypes","kind","formatIntervalType","typeName","match","subtype","closed","formatInterval","interval","toJSON","leftBracket","rightBracket","leftInterval","left","rightInterval","right","convertToSeconds","value","unit","unitAdjustment","Number","isSafeInteger","BigInt","formatTime","field","timeInSeconds","unix","utc","formatDuration","humanize","formatDecimal","scale","numString","bigNumToString","BN","padStart","sign","slice","wholePart","decimalPart","formatPeriodType","freq","formatPeriod","freqName","split","momentConverter","durationNumber","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","formatCategoricalType","x","extensionName","extensionMetadata","isDate","Date","isFinite","datetime","timezone","tz","zone","utcOffset","_key","cssId","cssStyles","headerColumns","headerRows","dataRows","rows","isEmpty","getCell","rowIndex","columnIndex","isBlankCell","isIndexCell","isColumnsCell","cssClass","BLANK","join","content","dataRowIndex","contentType","getIndexValue","INDEX","COLUMNS","UnicodeIndex","getDataValue","displayContent","DATA","addRows","other","draft","Object","fromEntries"],"sources":["../../src/dataframes/Quiver.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Private members use _.\n/* eslint-disable no-underscore-dangle */\n\nimport {\n  Schema as ArrowSchema,\n  Dictionary,\n  Field,\n  Null,\n  Struct,\n  StructRow,\n  Table,\n  tableFromIPC,\n  util,\n  Vector,\n} from \"apache-arrow\"\nimport { immerable, produce } from \"immer\"\nimport range from \"lodash/range\"\nimport unzip from \"lodash/unzip\"\nimport zip from \"lodash/zip\"\nimport trimEnd from \"lodash/trimEnd\"\nimport moment from \"moment-timezone\"\nimport numbro from \"numbro\"\n\nimport {\n  isNullOrUndefined,\n  notNullOrUndefined,\n} from \"@streamlit/lib/src/util/utils\"\nimport { IArrow, Styler as StylerProto } from \"@streamlit/lib/src/proto\"\nimport { logWarning } from \"@streamlit/lib/src/util/log\"\n\n/** Data types used by ArrowJS. */\nexport type DataType =\n  | null\n  | boolean\n  | number\n  | string\n  | Date // datetime\n  | Int32Array // int\n  | Uint8Array // bytes\n  | Uint32Array // Decimal\n  | Vector // arrays\n  | StructRow // interval\n  | Dictionary // categorical\n  | Struct // dict\n  | bigint // period\n\n/**\n * A row-major grid of DataFrame index header values.\n */\ntype IndexValue = Vector | number[]\n\n/**\n * A row-major grid of DataFrame index header values.\n */\ntype Index = IndexValue[]\n\n/**\n * A row-major grid of DataFrame column header values.\n * NOTE: ArrowJS automatically formats the columns in schema, i.e. we always get strings.\n */\ntype Columns = string[][]\n\n/**\n * A row-major grid of DataFrame data.\n */\ntype Data = Table\n\n// This type should be recursive as there can be nested structures.\n// Example: list[int64], list[list[unicode]], etc.\n// NOTE: Commented out until we can find a way to properly define recursive types.\n//\n// enum DataTypeName {\n//   Empty = \"empty\",\n//   Boolean = \"bool\",\n//   Number = \"int64\",\n//   Float = \"float64\",\n//   String = \"unicode\",\n//   Date = \"date\", // \"datetime\", \"datetimetz\"\n//   Bytes = \"bytes\",\n//   Object = \"object\",\n//   List = \"list[int64]\",\n// }\n\n/** DataFrame index and data types. */\ninterface Types {\n  /** Types for each index column. */\n  index: Type[]\n\n  /** Types for each data column. */\n  // NOTE: `DataTypeName` should be used here, but as it's hard (maybe impossible)\n  // to define such recursive types in TS, `string` will suffice for now.\n  data: Type[]\n}\n\n/** Type information for single-index columns, and data columns. */\nexport interface Type {\n  /** The type label returned by pandas.api.types.infer_dtype */\n  // NOTE: `DataTypeName` should be used here, but as it's hard (maybe impossible)\n  // to define such recursive types in TS, `string` will suffice for now.\n  pandas_type: IndexTypeName | string\n\n  /** The numpy dtype that corresponds to the types returned in df.dtypes */\n  numpy_type: string\n\n  /** Type metadata. */\n  meta?: Record<string, any> | null\n}\n\ntype IntervalData = \"int64\" | \"uint64\" | \"float64\" | \"datetime64[ns]\"\ntype IntervalClosed = \"left\" | \"right\" | \"both\" | \"neither\"\ntype IntervalType = `interval[${IntervalData}, ${IntervalClosed}]`\n\n// The frequency strings defined in pandas.\n// See: https://pandas.pydata.org/docs/user_guide/timeseries.html#period-aliases\n// Not supported: \"N\" (nanoseconds), \"U\" & \"us\" (microseconds), and \"B\" (business days).\n// Reason is that these types are not supported by moment.js, but also they are not\n// very commonly used in practice.\ntype SupportedPandasOffsetType =\n  // yearly frequency:\n  | \"A\" // deprecated alias\n  | \"Y\"\n  // quarterly frequency:\n  | \"Q\"\n  // monthly frequency:\n  | \"M\"\n  // weekly frequency:\n  | \"W\"\n  // calendar day frequency:\n  | \"D\"\n  // hourly frequency:\n  | \"H\" // deprecated alias\n  | \"h\"\n  // minutely frequency\n  | \"T\" // deprecated alias\n  | \"min\"\n  // secondly frequency:\n  | \"S\" // deprecated alias\n  | \"s\"\n  // milliseconds frequency:\n  | \"L\" // deprecated alias\n  | \"ms\"\n\ntype PeriodFrequency =\n  | SupportedPandasOffsetType\n  | `${SupportedPandasOffsetType}-${string}`\ntype PeriodType = `period[${PeriodFrequency}]`\n\nconst WEEKDAY_SHORT = [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"]\nconst formatMs = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"ms\")\n    .format(\"YYYY-MM-DD HH:mm:ss.SSS\")\n\nconst formatSec = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"s\")\n    .format(\"YYYY-MM-DD HH:mm:ss\")\n\nconst formatMin = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"m\").format(\"YYYY-MM-DD HH:mm\")\n\nconst formatHours = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"h\").format(\"YYYY-MM-DD HH:mm\")\n\nconst formatDay = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"d\").format(\"YYYY-MM-DD\")\n\nconst formatMonth = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"M\").format(\"YYYY-MM\")\n\nconst formatYear = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\").add(duration, \"y\").format(\"YYYY\")\n\nconst formatWeeks = (duration: number, freqParam?: string): string => {\n  if (!freqParam) {\n    throw new Error('Frequency \"W\" requires parameter')\n  }\n  const dayIndex = WEEKDAY_SHORT.indexOf(freqParam)\n  if (dayIndex < 0) {\n    throw new Error(\n      `Invalid value: ${freqParam}. Supported values: ${JSON.stringify(\n        WEEKDAY_SHORT\n      )}`\n    )\n  }\n  const startDate = moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"w\")\n    .day(dayIndex - 6)\n    .format(\"YYYY-MM-DD\")\n  const endDate = moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"w\")\n    .day(dayIndex)\n    .format(\"YYYY-MM-DD\")\n\n  return `${startDate}/${endDate}`\n}\n\nconst formatQuarter = (duration: number): string =>\n  moment(\"19700101\", \"YYYYMMDD\")\n    .add(duration, \"Q\")\n    .endOf(\"quarter\")\n    .format(\"YYYY[Q]Q\")\n\nconst PERIOD_TYPE_FORMATTERS: Record<\n  SupportedPandasOffsetType,\n  (duration: number, freqParam?: string) => string\n> = {\n  L: formatMs,\n  ms: formatMs,\n  S: formatSec,\n  s: formatSec,\n  T: formatMin,\n  min: formatMin,\n  H: formatHours,\n  h: formatHours,\n  D: formatDay,\n  M: formatMonth,\n  W: formatWeeks,\n  Q: formatQuarter,\n  Y: formatYear,\n  A: formatYear,\n}\n\n/** Interval data type. */\ninterface Interval {\n  left: number\n  right: number\n}\n\nexport enum IndexTypeName {\n  CategoricalIndex = \"categorical\",\n  DatetimeIndex = \"datetime\",\n  Float64Index = \"float64\",\n  Int64Index = \"int64\",\n  RangeIndex = \"range\",\n  UInt64Index = \"uint64\",\n  UnicodeIndex = \"unicode\",\n\n  // Throws an error.\n  TimedeltaIndex = \"time\",\n}\n\n/**\n * The Arrow table schema. It's a blueprint that tells us where data\n * is stored in the associated table. (Arrow stores the schema as a JSON string,\n * and we parse it into this typed object - so these member names come from\n * Arrow.)\n */\ninterface Schema {\n  /**\n   * The DataFrame's index names (either provided by user or generated,\n   * guaranteed unique). It is used to fetch the index data. Each DataFrame has\n   * at least 1 index. There are many different index types; for most of them\n   * the index name is stored as a string, but for the \"range\" index a `RangeIndex`\n   * object is used. A `RangeIndex` is only ever by itself, never as part of a\n   * multi-index. The length represents the dimensions of the DataFrame's index grid.\n   *\n   * Example:\n   * Range index: [{ kind: \"range\", name: null, start: 1, step: 1, stop: 5 }]\n   * Other index types: [\"__index_level_0__\", \"foo\", \"bar\"]\n   */\n  index_columns: (string | RangeIndex)[]\n\n  /**\n   * Schemas for each column (index *and* data columns) in the DataFrame.\n   */\n  columns: ColumnSchema[]\n\n  /**\n   * DataFrame column headers.\n   * The length represents the dimensions of the DataFrame's columns grid.\n   */\n  column_indexes: ColumnSchema[]\n}\n\n/** Metadata for the \"range\" index type. */\ninterface RangeIndex {\n  kind: \"range\"\n  name: string | null\n  start: number\n  step: number\n  stop: number\n}\n\n/**\n * Metadata for a single column in an Arrow table.\n * (This can describe an index *or* a data column.)\n */\ninterface ColumnSchema {\n  /**\n   * The fieldName of the column.\n   * For a single-index column, this is just the name of the column (e.g. \"foo\").\n   * For a multi-index column, this is a stringified tuple (e.g. \"('1','foo')\")\n   */\n  field_name: string\n\n  /**\n   * Column-specific metadata. Only used by certain column types\n   * (e.g. CategoricalIndex has `num_categories`.)\n   */\n  metadata: Record<string, any> | null\n\n  /** The name of the column. */\n  name: string | null\n\n  /**\n   * The type of the column. When `pandas_type == \"object\"`, `numpy_type`\n   * will have a more specific type.\n   */\n  pandas_type: string\n\n  /**\n   * When `pandas_type === \"object\"`, this field contains the object type.\n   * If pandas_type has another value, numpy_type is ignored.\n   */\n  numpy_type: string\n}\n\n/** DataFrame's Styler information. */\ninterface Styler {\n  /** Styler's UUID. */\n  uuid: string\n\n  /** Optional user-specified caption. */\n  caption: string | null\n\n  /** DataFrame's CSS styles. */\n  styles: string | null\n\n  /**\n   * Stringified versions of each cell in the DataFrame, in the\n   * user-specified format.\n   */\n  displayValues: Quiver\n}\n\n/** Dimensions of the DataFrame. */\ninterface DataFrameDimensions {\n  headerRows: number\n  headerColumns: number\n  dataRows: number\n  dataColumns: number\n  rows: number\n  columns: number\n}\n\n/**\n * There are 4 cell types:\n *  - blank, cells that are not part of index headers, column headers, or data\n *  - index, index header cells\n *  - columns, column header cells\n *  - data, data cells\n */\nexport enum DataFrameCellType {\n  BLANK = \"blank\",\n  INDEX = \"index\",\n  COLUMNS = \"columns\",\n  DATA = \"data\",\n}\n\n/** Data for a single cell in a DataFrame. */\nexport interface DataFrameCell {\n  /** The cell's type (blank, index, columns, or data). */\n  type: DataFrameCellType\n\n  /** The cell's CSS id, if the DataFrame has Styler. */\n  cssId?: string\n\n  /** The cell's CSS class. */\n  cssClass: string\n\n  /** The cell's content. */\n  content: DataType\n\n  /** The cell's content type. */\n  // For \"blank\" cells \"contentType\" is undefined.\n  contentType?: Type\n\n  /** The cell's field. */\n  field?: Field\n\n  /**\n   * The cell's formatted content string, if the DataFrame was created with a Styler.\n   * If the DataFrame is unstyled, displayContent will be undefined, and display\n   * code should apply a default formatting to the `content` value instead.\n   */\n  displayContent?: string\n}\n\n/**\n * Parses data from an Arrow table, and stores it in a row-major format\n * (which is more useful for our frontend display code than Arrow's columnar format).\n */\nexport class Quiver {\n  /**\n   * Plain objects (objects without a prototype), arrays, Maps and Sets are always drafted by Immer.\n   * Every other object must use the immerable symbol to mark itself as compatible with Immer.\n   * When one of these objects is mutated within a producer, its prototype is preserved between copies.\n   * Source: https://immerjs.github.io/immer/complex-objects/\n   */\n  [immerable] = true\n\n  /** DataFrame's index (matrix of row names). */\n  private _index: Index\n\n  /** DataFrame's column labels (matrix of column names). */\n  private _columns: Columns\n\n  /** DataFrame's index names. */\n  private _indexNames: string[]\n\n  /** DataFrame's data. */\n  private _data: Data\n\n  /** Definition for DataFrame's fields. */\n  private _fields: Record<string, Field<any>>\n\n  /** Types for DataFrame's index and data. */\n  private _types: Types\n\n  /** [optional] DataFrame's Styler data. This will be defined if the user styled the dataframe. */\n  private readonly _styler?: Styler\n\n  constructor(element: IArrow) {\n    const table = tableFromIPC(element.data)\n    const schema = Quiver.parseSchema(table)\n    const rawColumns = Quiver.getRawColumns(schema)\n    const fields = Quiver.parseFields(table.schema)\n\n    const index = Quiver.parseIndex(table, schema)\n    const columns = Quiver.parseColumns(schema)\n    const indexNames = Quiver.parseIndexNames(schema)\n    const data = Quiver.parseData(table, columns, rawColumns)\n    const types = Quiver.parseTypes(table, schema)\n    const styler = element.styler\n      ? Quiver.parseStyler(element.styler as StylerProto)\n      : undefined\n\n    // The assignment is done below to avoid partially populating the instance\n    // if an error is thrown.\n    this._index = index\n    this._columns = columns\n    this._data = data\n    this._types = types\n    this._fields = fields\n    this._styler = styler\n    this._indexNames = indexNames\n  }\n\n  /** Parse Arrow table's schema from a JSON string to an object. */\n  private static parseSchema(table: Table): Schema {\n    const schema = table.schema.metadata.get(\"pandas\")\n    if (isNullOrUndefined(schema)) {\n      // This should never happen!\n      throw new Error(\"Table schema is missing.\")\n    }\n    return JSON.parse(schema)\n  }\n\n  /** Get unprocessed column names for data columns. Needed for selecting\n   * data columns when there are multi-columns. */\n  private static getRawColumns(schema: Schema): string[] {\n    return (\n      schema.columns\n        .map(columnSchema => columnSchema.field_name)\n        // Filter out all index columns\n        .filter(columnName => !schema.index_columns.includes(columnName))\n    )\n  }\n\n  /** Parse DataFrame's index header values. */\n  private static parseIndex(table: Table, schema: Schema): Index {\n    return schema.index_columns\n      .map(indexName => {\n        // Generate a range using the \"range\" index metadata.\n        if (Quiver.isRangeIndex(indexName)) {\n          const { start, stop, step } = indexName\n          return range(start, stop, step)\n        }\n\n        // Otherwise, use the index name to get the index column data.\n        const column = table.getChild(indexName as string)\n        if (column instanceof Vector && column.type instanceof Null) {\n          return null\n        }\n        return column\n      })\n      .filter(\n        (column: IndexValue | null): column is IndexValue => column !== null\n      )\n  }\n\n  /** Parse DataFrame's index header names. */\n  private static parseIndexNames(schema: Schema): string[] {\n    return schema.index_columns.map(indexName => {\n      // Range indices are treated differently since they\n      // contain additional metadata (e.g. start, stop, step).\n      // and not just the name.\n      if (Quiver.isRangeIndex(indexName)) {\n        const { name } = indexName\n        return name || \"\"\n      }\n      if (indexName.startsWith(\"__index_level_\")) {\n        // Unnamed indices can have a name like \"__index_level_0__\".\n        return \"\"\n      }\n      return indexName\n    })\n  }\n\n  /** Parse DataFrame's column header values. */\n  private static parseColumns(schema: Schema): Columns {\n    // If DataFrame `columns` has multi-level indexing, the length of\n    // `column_indexes` will show how many levels there are.\n    const isMultiIndex = schema.column_indexes.length > 1\n\n    // Perform the following transformation:\n    // [\"('1','foo')\", \"('2','bar')\", \"('3','baz')\"] -> ... -> [[\"1\", \"2\", \"3\"], [\"foo\", \"bar\", \"baz\"]]\n    return unzip(\n      schema.columns\n        .map(columnSchema => columnSchema.field_name)\n        // Filter out all index columns\n        .filter(fieldName => !schema.index_columns.includes(fieldName))\n        .map(fieldName =>\n          isMultiIndex\n            ? JSON.parse(\n                fieldName\n                  .replace(/\\(/g, \"[\")\n                  .replace(/\\)/g, \"]\")\n                  .replace(/'/g, '\"')\n              )\n            : [fieldName]\n        )\n    )\n  }\n\n  /** Parse DataFrame's data. */\n  private static parseData(\n    table: Table,\n    columns: Columns,\n    rawColumns: string[]\n  ): Data {\n    const numDataRows = table.numRows\n    const numDataColumns = columns.length > 0 ? columns[0].length : 0\n    if (numDataRows === 0 || numDataColumns === 0) {\n      return table.select([])\n    }\n\n    return table.select(rawColumns)\n  }\n\n  /** Parse DataFrame's index and data types. */\n  private static parseTypes(table: Table, schema: Schema): Types {\n    const index = Quiver.parseIndexType(schema)\n    const data = Quiver.parseDataType(table, schema)\n    return { index, data }\n  }\n\n  /** Parse types for each index column. */\n  private static parseIndexType(schema: Schema): Type[] {\n    return schema.index_columns.map(indexName => {\n      if (Quiver.isRangeIndex(indexName)) {\n        return {\n          pandas_type: IndexTypeName.RangeIndex,\n          numpy_type: IndexTypeName.RangeIndex,\n          meta: indexName as RangeIndex,\n        }\n      }\n\n      // Find the index column we're looking for in the schema.\n      const indexColumn = schema.columns.find(\n        column => column.field_name === indexName\n      )\n\n      // This should never happen!\n      if (!indexColumn) {\n        throw new Error(`${indexName} index not found.`)\n      }\n\n      return {\n        pandas_type: indexColumn.pandas_type,\n        numpy_type: indexColumn.numpy_type,\n        meta: indexColumn.metadata,\n      }\n    })\n  }\n\n  /**\n   * Returns the categorical options defined for a given data column.\n   * Returns undefined if the column is not categorical.\n   *\n   * This function only works for non-index columns and expects the index at 0\n   * for the first non-index data column.\n   */\n  public getCategoricalOptions(dataColumnIndex: number): string[] | undefined {\n    const { dataColumns: numDataColumns } = this.dimensions\n\n    if (dataColumnIndex < 0 || dataColumnIndex >= numDataColumns) {\n      throw new Error(`Column index is out of range: ${dataColumnIndex}`)\n    }\n\n    if (!(this._fields[String(dataColumnIndex)].type instanceof Dictionary)) {\n      // This is not a categorical column\n      return undefined\n    }\n\n    const categoricalDict =\n      this._data.getChildAt(dataColumnIndex)?.data[0]?.dictionary\n    if (categoricalDict) {\n      // get all values into a list\n      const values = []\n\n      for (let i = 0; i < categoricalDict.length; i++) {\n        values.push(categoricalDict.get(i))\n      }\n      return values\n    }\n    return undefined\n  }\n\n  /** Parse types for each non-index column. */\n  private static parseDataType(table: Table, schema: Schema): Type[] {\n    return (\n      schema.columns\n        // Filter out all index columns\n        .filter(\n          columnSchema =>\n            !schema.index_columns.includes(columnSchema.field_name)\n        )\n        .map(columnSchema => ({\n          pandas_type: columnSchema.pandas_type,\n          numpy_type: columnSchema.numpy_type,\n          meta: columnSchema.metadata,\n        }))\n    )\n  }\n\n  /** Parse styler information from proto. */\n  private static parseStyler(styler: StylerProto): Styler {\n    return {\n      uuid: styler.uuid,\n      caption: styler.caption,\n      styles: styler.styles,\n\n      // Recursively create a new Quiver instance for Styler's display values.\n      // This values will be used for rendering the DataFrame, while the original values\n      // will be used for sorting, etc.\n      displayValues: new Quiver({ data: styler.displayValues }),\n    }\n  }\n\n  /** Concatenate the original DataFrame index with the given one. */\n  private concatIndexes(otherIndex: Index, otherIndexTypes: Type[]): Index {\n    // If one of the `index` arrays is empty, return the other one.\n    // Otherwise, they will have different types and an error will be thrown.\n    if (otherIndex.length === 0) {\n      return this._index\n    }\n    if (this._index.length === 0) {\n      return otherIndex\n    }\n\n    // Make sure indexes have same types.\n    if (!Quiver.sameIndexTypes(this._types.index, otherIndexTypes)) {\n      const receivedIndexTypes = otherIndexTypes.map(index =>\n        Quiver.getTypeName(index)\n      )\n      const expectedIndexTypes = this._types.index.map(index =>\n        Quiver.getTypeName(index)\n      )\n\n      throw new Error(`\nUnsupported operation. The data passed into \\`add_rows()\\` must have the same\nindex signature as the original data.\n\nIn this case, \\`add_rows()\\` received \\`${JSON.stringify(receivedIndexTypes)}\\`\nbut was expecting \\`${JSON.stringify(expectedIndexTypes)}\\`.\n`)\n    }\n\n    if (this._types.index.length === 0) {\n      // This should never happen!\n      throw new Error(\"There was an error while parsing index types.\")\n    }\n\n    // NOTE: \"range\" index cannot be a part of a multi-index, i.e.\n    // if the index type is \"range\", there will only be one element in the index array.\n    if (this._types.index[0].pandas_type === IndexTypeName.RangeIndex) {\n      // Continue the sequence for a \"range\" index.\n      // NOTE: The metadata of the original index will be used, i.e.\n      // if both indexes are of type \"range\" and they have different\n      // metadata (start, step, stop) values, the metadata of the given\n      // index will be ignored.\n      const { step, stop } = this._types.index[0].meta as RangeIndex\n      otherIndex = [\n        range(\n          stop,\n          // End is not inclusive\n          stop + otherIndex[0].length * step,\n          step\n        ),\n      ]\n    }\n\n    // Concatenate each index with its counterpart in the other table\n    const zipped = zip(this._index, otherIndex)\n    // @ts-expect-error We know the two indexes are of the same size\n    return zipped.map(a => a[0].concat(a[1]))\n  }\n\n  /** True if both arrays contain the same index types in the same order. */\n  private static sameIndexTypes(t1: Type[], t2: Type[]): boolean {\n    // Make sure both indexes have same dimensions.\n    if (t1.length !== t2.length) {\n      return false\n    }\n\n    return t1.every(\n      (type: Type, index: number) =>\n        index < t2.length &&\n        Quiver.getTypeName(type) === Quiver.getTypeName(t2[index])\n    )\n  }\n\n  /** Concatenate the original DataFrame data with the given one. */\n  private concatData(otherData: Data, otherDataType: Type[]): Data {\n    // If one of the `data` arrays is empty, return the other one.\n    // Otherwise, they will have different types and an error will be thrown.\n    if (otherData.numCols === 0) {\n      return this._data\n    }\n    if (this._data.numCols === 0) {\n      return otherData\n    }\n\n    // Make sure `data` arrays have the same types.\n    if (!Quiver.sameDataTypes(this._types.data, otherDataType)) {\n      const receivedDataTypes = otherDataType.map(t => t.pandas_type)\n      const expectedDataTypes = this._types.data.map(t => t.pandas_type)\n\n      throw new Error(`\nUnsupported operation. The data passed into \\`add_rows()\\` must have the same\ndata signature as the original data.\n\nIn this case, \\`add_rows()\\` received \\`${JSON.stringify(receivedDataTypes)}\\`\nbut was expecting \\`${JSON.stringify(expectedDataTypes)}\\`.\n`)\n    }\n\n    // Remove extra columns from the \"other\" DataFrame.\n    // Columns from otherData are used by index without checking column names.\n    const slicedOtherData = otherData.selectAt(range(0, this._data.numCols))\n    return this._data.concat(slicedOtherData)\n  }\n\n  /** True if both arrays contain the same data types in the same order. */\n  private static sameDataTypes(t1: Type[], t2: Type[]): boolean {\n    // NOTE: We remove extra columns from the DataFrame that we add rows from.\n    // Thus, as long as the length of `t2` is >= than `t1`, this will work properly.\n    // For columns, `pandas_type` will point us to the correct type.\n    return t1.every(\n      (type: Type, index: number) =>\n        type.pandas_type === t2[index]?.pandas_type\n    )\n  }\n\n  /** Concatenate index and data types. */\n  private concatTypes(otherTypes: Types): Types {\n    const index = this.concatIndexTypes(otherTypes.index)\n    const data = this.concatDataTypes(otherTypes.data)\n    return { index, data }\n  }\n\n  /** Concatenate index types. */\n  private concatIndexTypes(otherIndexTypes: Type[]): Type[] {\n    // If one of the `types` arrays is empty, return the other one.\n    // Otherwise, an empty array will be returned.\n    if (otherIndexTypes.length === 0) {\n      return this._types.index\n    }\n    if (this._types.index.length === 0) {\n      return otherIndexTypes\n    }\n\n    // Make sure indexes have same types.\n    if (!Quiver.sameIndexTypes(this._types.index, otherIndexTypes)) {\n      const receivedIndexTypes = otherIndexTypes.map(index =>\n        Quiver.getTypeName(index)\n      )\n      const expectedIndexTypes = this._types.index.map(index =>\n        Quiver.getTypeName(index)\n      )\n\n      throw new Error(`\nUnsupported operation. The data passed into \\`add_rows()\\` must have the same\nindex signature as the original data.\n\nIn this case, \\`add_rows()\\` received \\`${JSON.stringify(receivedIndexTypes)}\\`\nbut was expecting \\`${JSON.stringify(expectedIndexTypes)}\\`.\n`)\n    }\n\n    // TL;DR This sets the new stop value.\n    return this._types.index.map(indexType => {\n      // NOTE: \"range\" index cannot be a part of a multi-index, i.e.\n      // if the index type is \"range\", there will only be one element in the index array.\n      if (indexType.pandas_type === IndexTypeName.RangeIndex) {\n        const { stop, step } = indexType.meta as RangeIndex\n        const {\n          start: otherStart,\n          stop: otherStop,\n          step: otherStep,\n        } = otherIndexTypes[0].meta as RangeIndex\n        const otherRangeIndexLength = (otherStop - otherStart) / otherStep\n        const newStop = stop + otherRangeIndexLength * step\n        return {\n          ...indexType,\n          meta: {\n            ...indexType.meta,\n            stop: newStop,\n          },\n        }\n      }\n      return indexType\n    })\n  }\n\n  /** Concatenate types of data columns. */\n  private concatDataTypes(otherDataTypes: Type[]): Type[] {\n    if (this._types.data.length === 0) {\n      return otherDataTypes\n    }\n\n    return this._types.data\n  }\n\n  /** True if the index name represents a \"range\" index. */\n  private static isRangeIndex(\n    indexName: string | RangeIndex\n  ): indexName is RangeIndex {\n    return typeof indexName === \"object\" && indexName.kind === \"range\"\n  }\n\n  /** Formats an interval index. */\n  private static formatIntervalType(\n    data: StructRow,\n    typeName: IntervalType\n  ): string {\n    const match = typeName.match(/interval\\[(.+), (both|left|right|neither)\\]/)\n    if (match === null) {\n      throw new Error(`Invalid interval type: ${typeName}`)\n    }\n    const [, subtype, closed] = match\n    return this.formatInterval(data, subtype, closed as IntervalClosed)\n  }\n\n  private static formatInterval(\n    data: StructRow,\n    subtype: string,\n    closed: IntervalClosed\n  ): string {\n    const interval = data.toJSON() as Interval\n\n    const leftBracket = closed === \"both\" || closed === \"left\" ? \"[\" : \"(\"\n    const rightBracket = closed === \"both\" || closed === \"right\" ? \"]\" : \")\"\n    const leftInterval = Quiver.format(interval.left, {\n      pandas_type: subtype,\n      numpy_type: subtype,\n    })\n    const rightInterval = Quiver.format(interval.right, {\n      pandas_type: subtype,\n      numpy_type: subtype,\n    })\n\n    return `${leftBracket + leftInterval}, ${rightInterval + rightBracket}`\n  }\n\n  /**\n   * Adjusts a time value to seconds based on the unit information in the field.\n   *\n   * The unit numbers are specified here:\n   * https://github.com/apache/arrow/blob/3ab246f374c17a216d86edcfff7ff416b3cff803/js/src/enum.ts#L95\n   */\n  public static convertToSeconds(\n    value: number | bigint,\n    unit: number\n  ): number {\n    let unitAdjustment\n\n    if (unit === 1) {\n      // Milliseconds\n      unitAdjustment = 1000\n    } else if (unit === 2) {\n      // Microseconds\n      unitAdjustment = 1000 * 1000\n    } else if (unit === 3) {\n      // Nanoseconds\n      unitAdjustment = 1000 * 1000 * 1000\n    } else {\n      // Interpret it as seconds as a fallback\n      return Number(value)\n    }\n\n    // Do the calculation based on bigints, if the value\n    // is a bigint and not safe for usage as number.\n    // This might lose some precision since it doesn't keep\n    // fractional parts.\n    if (typeof value === \"bigint\" && !Number.isSafeInteger(Number(value))) {\n      return Number(value / BigInt(unitAdjustment))\n    }\n\n    return Number(value) / unitAdjustment\n  }\n\n  private static formatTime(data: number, field?: Field): string {\n    const timeInSeconds = Quiver.convertToSeconds(data, field?.type?.unit ?? 0)\n    return moment\n      .unix(timeInSeconds)\n      .utc()\n      .format(timeInSeconds % 1 === 0 ? \"HH:mm:ss\" : \"HH:mm:ss.SSS\")\n  }\n\n  private static formatDuration(data: number | bigint, field?: Field): string {\n    return moment\n      .duration(\n        Quiver.convertToSeconds(data, field?.type?.unit ?? 3),\n        \"seconds\"\n      )\n      .humanize()\n  }\n\n  /**\n   * Formats a decimal value with a given scale to a string.\n   *\n   * This code is partly based on: https://github.com/apache/arrow/issues/35745\n   *\n   * TODO: This is only a temporary workaround until ArrowJS can format decimals correctly.\n   * This is tracked here:\n   * https://github.com/apache/arrow/issues/37920\n   * https://github.com/apache/arrow/issues/28804\n   * https://github.com/apache/arrow/issues/35745\n   */\n  private static formatDecimal(value: Uint32Array, scale: number): string {\n    // Format Uint32Array to a numerical string and pad it with zeros\n    // So that it is exactly the length of the scale.\n    let numString = util\n      .bigNumToString(new util.BN(value))\n      .padStart(scale, \"0\")\n\n    // ArrowJS 13 correctly adds a minus sign for negative numbers.\n    // but it doesn't handle th fractional part yet. So we can just return\n    // the value if scale === 0, but we need to do some additional processing\n    // for the fractional part if scale > 0.\n\n    if (scale === 0) {\n      return numString\n    }\n\n    let sign = \"\"\n    if (numString.startsWith(\"-\")) {\n      // Check if number is negative, and if so remember the sign and remove it.\n      // We will add it back later.\n      sign = \"-\"\n      numString = numString.slice(1)\n    }\n    // Extract the whole number part. If the number is < 1, it doesn't\n    // have a whole number part, so we'll use \"0\" instead.\n    // E.g for 123450 with scale 3, we'll get \"123\" as the whole part.\n    const wholePart = numString.slice(0, -scale) || \"0\"\n    // Extract the fractional part and remove trailing zeros.\n    // E.g. for 123450 with scale 3, we'll get \"45\" as the fractional part.\n    const decimalPart = trimEnd(numString.slice(-scale), \"0\") || \"\"\n    // Combine the parts and add the sign.\n    return `${sign}${wholePart}` + (decimalPart ? `.${decimalPart}` : \"\")\n  }\n\n  public static formatPeriodType(\n    duration: bigint,\n    typeName: PeriodType\n  ): string {\n    const match = typeName.match(/period\\[(.*)]/)\n    if (match === null) {\n      logWarning(`Invalid period type: ${typeName}`)\n      return String(duration)\n    }\n    const [, freq] = match\n    return this.formatPeriod(duration, freq as PeriodFrequency)\n  }\n\n  private static formatPeriod(\n    duration: bigint,\n    freq: PeriodFrequency\n  ): string {\n    const [freqName, freqParam] = freq.split(\"-\", 2)\n    const momentConverter =\n      PERIOD_TYPE_FORMATTERS[freqName as SupportedPandasOffsetType]\n    if (!momentConverter) {\n      logWarning(`Unsupported period frequency: ${freq}`)\n      return String(duration)\n    }\n    const durationNumber = Number(duration)\n    if (!Number.isSafeInteger(durationNumber)) {\n      logWarning(\n        `Unsupported value: ${duration}. Supported values: [${Number.MIN_SAFE_INTEGER}-${Number.MAX_SAFE_INTEGER}]`\n      )\n      return String(duration)\n    }\n    return momentConverter(durationNumber, freqParam)\n  }\n\n  private static formatCategoricalType(\n    x: number | bigint | StructRow,\n    field: Field\n  ): string {\n    // Serialization for pandas.Interval and pandas.Period is provided by Arrow extensions\n    // https://github.com/pandas-dev/pandas/blob/235d9009b571c21b353ab215e1e675b1924ae55c/\n    // pandas/core/arrays/arrow/extension_types.py#L17\n    const extensionName = field.metadata.get(\"ARROW:extension:name\")\n    if (extensionName) {\n      const extensionMetadata = JSON.parse(\n        field.metadata.get(\"ARROW:extension:metadata\") as string\n      )\n      if (extensionName === \"pandas.interval\") {\n        const { subtype, closed } = extensionMetadata\n        return Quiver.formatInterval(x as StructRow, subtype, closed)\n      }\n      if (extensionName === \"pandas.Period\") {\n        const { freq } = extensionMetadata\n        return Quiver.formatPeriod(x as bigint, freq)\n      }\n    }\n    return String(x)\n  }\n\n  /** Returns type for a single-index column or data column. */\n  public static getTypeName(type: Type): IndexTypeName | string {\n    // For `PeriodType` and `IntervalType` types are kept in `numpy_type`,\n    // for the rest of the indexes in `pandas_type`.\n    return type.pandas_type === \"object\" ? type.numpy_type : type.pandas_type\n  }\n\n  /** Takes the data and it's type and nicely formats it. */\n  public static format(x: DataType, type?: Type, field?: Field): string {\n    const typeName = type && Quiver.getTypeName(type)\n\n    if (isNullOrUndefined(x)) {\n      return \"<NA>\"\n    }\n\n    // date\n    const isDate = x instanceof Date || Number.isFinite(x)\n    if (isDate && typeName === \"date\") {\n      return moment.utc(x as Date | number).format(\"YYYY-MM-DD\")\n    }\n    // time\n    if (typeof x === \"bigint\" && typeName === \"time\") {\n      return Quiver.formatTime(Number(x), field)\n    }\n\n    // datetimetz\n    if (isDate && typeName === \"datetimetz\") {\n      const meta = type?.meta\n      let datetime = moment(x as Date | number)\n\n      if (meta?.timezone) {\n        if (moment.tz.zone(meta?.timezone)) {\n          // uses timezone notation\n          datetime = datetime.tz(meta?.timezone)\n        } else {\n          // uses UTC offset notation\n          datetime = datetime.utcOffset(meta?.timezone)\n        }\n      }\n\n      return datetime.format(\"YYYY-MM-DD HH:mm:ssZ\")\n    }\n    // datetime, datetime64, datetime64[ns], etc.\n    if (isDate && typeName?.startsWith(\"datetime\")) {\n      return moment.utc(x as Date | number).format(\"YYYY-MM-DD HH:mm:ss\")\n    }\n\n    if (typeName?.startsWith(\"interval\")) {\n      return Quiver.formatIntervalType(\n        x as StructRow,\n        typeName as IntervalType\n      )\n    }\n\n    if (typeName?.startsWith(\"period\")) {\n      return Quiver.formatPeriodType(x as bigint, typeName as PeriodType)\n    }\n\n    if (typeName === \"categorical\") {\n      return this.formatCategoricalType(\n        x as number | bigint | StructRow,\n        field as Field\n      )\n    }\n\n    if (typeName?.startsWith(\"timedelta\")) {\n      return this.formatDuration(x as number | bigint, field)\n    }\n\n    if (typeName === \"decimal\") {\n      return this.formatDecimal(x as Uint32Array, field?.type?.scale || 0)\n    }\n\n    // Nested arrays and objects.\n    if (typeName === \"object\" || typeName?.startsWith(\"list\")) {\n      if (field?.type instanceof Struct) {\n        // This type is used by python dictionary values\n\n        // Workaround: Arrow JS adds all properties from all cells\n        // as fields. When you convert to string, it will contain lots of fields with\n        // null values. To mitigate this, we filter out null values.\n\n        return JSON.stringify(x, (_key, value) => {\n          if (!notNullOrUndefined(value)) {\n            // Ignore null and undefined values ->\n            return undefined\n          }\n          if (typeof value === \"bigint\") {\n            return Number(value)\n          }\n          return value\n        })\n      }\n      return JSON.stringify(x, (_key, value) =>\n        typeof value === \"bigint\" ? Number(value) : value\n      )\n    }\n\n    if (typeName === \"float64\" && Number.isFinite(x)) {\n      return numbro(x).format(\"0,0.0000\")\n    }\n\n    return String(x)\n  }\n\n  /** DataFrame's index (matrix of row names). */\n  public get index(): Index {\n    return this._index\n  }\n\n  /** DataFrame's index names. */\n  public get indexNames(): string[] {\n    return this._indexNames\n  }\n\n  /** DataFrame's column labels (matrix of column names). */\n  public get columns(): Columns {\n    return this._columns\n  }\n\n  /** DataFrame's data. */\n  public get data(): Data {\n    return this._data\n  }\n\n  /** Types for DataFrame's index and data. */\n  public get types(): Types {\n    return this._types\n  }\n\n  /**\n   * The DataFrame's CSS id, if it has one.\n   *\n   * If the DataFrame has a Styler, the  CSS id is `T_${StylerUUID}`. Otherwise,\n   * it's undefined.\n   *\n   * This id is used by styled tables and styled dataframes to associate\n   * the Styler CSS with the styled data.\n   */\n  public get cssId(): string | undefined {\n    if (\n      isNullOrUndefined(this._styler) ||\n      isNullOrUndefined(this._styler.uuid)\n    ) {\n      return undefined\n    }\n\n    return `T_${this._styler.uuid}`\n  }\n\n  /** The DataFrame's CSS styles, if it has a Styler. */\n  public get cssStyles(): string | undefined {\n    return this._styler?.styles || undefined\n  }\n\n  /** The DataFrame's caption, if it's been set. */\n  public get caption(): string | undefined {\n    return this._styler?.caption || undefined\n  }\n\n  /** The DataFrame's dimensions. */\n  public get dimensions(): DataFrameDimensions {\n    const headerColumns = this._index.length || this.types.index.length || 1\n    const headerRows = this._columns.length || 1\n    const dataRows = this._data.numRows || 0\n    const dataColumns = this._data.numCols || this._columns?.[0]?.length || 0\n\n    const rows = headerRows + dataRows\n    const columns = headerColumns + dataColumns\n\n    return {\n      headerRows,\n      headerColumns,\n      dataRows,\n      dataColumns,\n      rows,\n      columns,\n    }\n  }\n\n  /** True if the DataFrame has no index, columns, and data. */\n  public isEmpty(): boolean {\n    return (\n      this._index.length === 0 &&\n      this._columns.length === 0 &&\n      this._data.numRows === 0 &&\n      this._data.numCols === 0\n    )\n  }\n\n  /** Return a single cell in the table. */\n  public getCell(rowIndex: number, columnIndex: number): DataFrameCell {\n    const { headerRows, headerColumns, rows, columns } = this.dimensions\n\n    if (rowIndex < 0 || rowIndex >= rows) {\n      throw new Error(`Row index is out of range: ${rowIndex}`)\n    }\n    if (columnIndex < 0 || columnIndex >= columns) {\n      throw new Error(`Column index is out of range: ${columnIndex}`)\n    }\n\n    const isBlankCell = rowIndex < headerRows && columnIndex < headerColumns\n    const isIndexCell = rowIndex >= headerRows && columnIndex < headerColumns\n    const isColumnsCell = rowIndex < headerRows && columnIndex >= headerColumns\n\n    if (isBlankCell) {\n      // Blank cells include `blank`.\n      const cssClass = [\"blank\"]\n      if (columnIndex > 0) {\n        cssClass.push(`level${rowIndex}`)\n      }\n\n      return {\n        type: DataFrameCellType.BLANK,\n        cssClass: cssClass.join(\" \"),\n        content: \"\",\n      }\n    }\n\n    if (isIndexCell) {\n      const dataRowIndex = rowIndex - headerRows\n\n      const cssId = this._styler?.uuid\n        ? `${this.cssId}level${columnIndex}_row${dataRowIndex}`\n        : undefined\n\n      // Index label cells include:\n      // - row_heading\n      // - row<n> where n is the numeric position of the row\n      // - level<k> where k is the level in a MultiIndex\n      const cssClass = [\n        `row_heading`,\n        `level${columnIndex}`,\n        `row${dataRowIndex}`,\n      ].join(\" \")\n\n      const contentType = this._types.index[columnIndex]\n      const content = this.getIndexValue(dataRowIndex, columnIndex)\n      let field = this._fields[`__index_level_${String(columnIndex)}__`]\n      if (field === undefined) {\n        // If the index column has a name, we need to get it differently:\n        field = this._fields[String(columns - headerColumns)]\n      }\n      return {\n        type: DataFrameCellType.INDEX,\n        cssId,\n        cssClass,\n        content,\n        contentType,\n        field,\n      }\n    }\n\n    if (isColumnsCell) {\n      const dataColumnIndex = columnIndex - headerColumns\n\n      // Column label cells include:\n      // - col_heading\n      // - col<n> where n is the numeric position of the column\n      // - level<k> where k is the level in a MultiIndex\n      const cssClass = [\n        `col_heading`,\n        `level${rowIndex}`,\n        `col${dataColumnIndex}`,\n      ].join(\" \")\n\n      return {\n        type: DataFrameCellType.COLUMNS,\n        cssClass,\n        content: this._columns[rowIndex][dataColumnIndex],\n        // ArrowJS automatically converts \"columns\" cells to strings.\n        // Keep ArrowJS structure for consistency.\n        contentType: {\n          pandas_type: IndexTypeName.UnicodeIndex,\n          numpy_type: \"object\",\n        },\n      }\n    }\n\n    const dataRowIndex = rowIndex - headerRows\n    const dataColumnIndex = columnIndex - headerColumns\n\n    const cssId = this._styler?.uuid\n      ? `${this.cssId}row${dataRowIndex}_col${dataColumnIndex}`\n      : undefined\n\n    // Data cells include `data`.\n    const cssClass = [\n      \"data\",\n      `row${dataRowIndex}`,\n      `col${dataColumnIndex}`,\n    ].join(\" \")\n\n    const contentType = this._types.data[dataColumnIndex]\n    const field = this._fields[String(dataColumnIndex)]\n    const content = this.getDataValue(dataRowIndex, dataColumnIndex)\n    const displayContent = this._styler?.displayValues\n      ? (this._styler.displayValues.getCell(rowIndex, columnIndex)\n          .content as string)\n      : undefined\n\n    return {\n      type: DataFrameCellType.DATA,\n      cssId,\n      cssClass,\n      content,\n      contentType,\n      displayContent,\n      field,\n    }\n  }\n\n  public getIndexValue(rowIndex: number, columnIndex: number): any {\n    const index = this._index[columnIndex]\n    const value =\n      index instanceof Vector ? index.get(rowIndex) : index[rowIndex]\n    return value\n  }\n\n  public getDataValue(rowIndex: number, columnIndex: number): any {\n    return this._data.getChildAt(columnIndex)?.get(rowIndex)\n  }\n\n  /**\n   * Add the contents of another table (data + indexes) to this table.\n   * Extra columns will not be created.\n   */\n  public addRows(other: Quiver): Quiver {\n    if (this._styler || other._styler) {\n      throw new Error(`\nUnsupported operation. \\`add_rows()\\` does not support Pandas Styler objects.\n\nIf you do not need the Styler's styles, try passing the \\`.data\\` attribute of\nthe Styler object instead to concatenate just the underlying dataframe.\n\nFor example:\n\\`\\`\\`\nst.add_rows(my_styler.data)\n\\`\\`\\`\n`)\n    }\n\n    // Don't do anything if the incoming DataFrame is empty.\n    if (other.isEmpty()) {\n      return produce(this, (draft: Quiver) => draft)\n    }\n\n    // We need to handle this separately, as columns need to be reassigned.\n    // We don't concatenate columns in the general case.\n    if (this.isEmpty()) {\n      return produce(other, (draft: Quiver) => draft)\n    }\n\n    // Concatenate all data into temporary variables. If any of\n    // these operations fail, an error will be thrown and we'll prematurely\n    // exit the function.\n    const index = this.concatIndexes(other._index, other._types.index)\n    const data = this.concatData(other._data, other._types.data)\n    const types = this.concatTypes(other._types)\n\n    // If we get here, then we had no concatenation errors.\n    return produce(this, (draft: Quiver) => {\n      draft._index = index\n      draft._data = data\n      draft._types = types\n    })\n  }\n\n  private static parseFields(schema: ArrowSchema): Record<string, Field> {\n    // None-index data columns are listed first, and all index columns listed last\n    // within the fields array in arrow.\n    return Object.fromEntries(\n      (schema.fields || []).map((field, index) => [\n        field.name.startsWith(\"__index_level_\") ? field.name : String(index),\n        field,\n      ])\n    )\n  }\n}\n"],"mappings":"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"}