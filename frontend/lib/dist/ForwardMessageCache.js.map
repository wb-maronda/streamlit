{"version":3,"file":"ForwardMessageCache.js","names":["ForwardMsg","logMessage","ensureError","CacheEntry","getAge","curScriptRunCount","scriptRunCount","constructor","encodedMsg","ForwardMsgCache","endpoints","messages","Map","incrementRunCount","maxMessageAge","forEach","entry","hash","concat","delete","processMessagePayload","msg","maybeCacheMessage","type","newMsg","getCachedMessage","refHash","encodedNewMsg","fetchCachedForwardMsg","decode","e","Error","message","metadata","cacheable","undefined","set","updateScriptRunCount","cached","get"],"sources":["../src/ForwardMessageCache.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ForwardMsg } from \"./proto\"\nimport { logMessage } from \"./util/log\"\nimport { ensureError } from \"./util/ErrorHandling\"\nimport { StreamlitEndpoints } from \"./StreamlitEndpoints\"\n\nclass CacheEntry {\n  public readonly encodedMsg: Uint8Array\n\n  public scriptRunCount = 0\n\n  public getAge(curScriptRunCount: number): number {\n    return curScriptRunCount - this.scriptRunCount\n  }\n\n  constructor(encodedMsg: Uint8Array, scriptRunCount: number) {\n    this.encodedMsg = encodedMsg\n    this.scriptRunCount = scriptRunCount\n  }\n}\n\n/**\n * Handles ForwardMsg caching for WebsocketConnection.\n */\nexport class ForwardMsgCache {\n  private readonly messages = new Map<string, CacheEntry>()\n\n  private readonly endpoints: StreamlitEndpoints\n\n  /**\n   * A counter that tracks the number of times the underlying script\n   * has been run. We use this to expire our cache entries.\n   */\n  private scriptRunCount = 0\n\n  constructor(endpoints: StreamlitEndpoints) {\n    this.endpoints = endpoints\n  }\n\n  /**\n   * Increment our scriptRunCount, and remove all entries from the cache\n   * that have expired. This should be called after the script has finished\n   * running.\n   *\n   * @param maxMessageAge Max age of a message in the cache.\n   * The \"age\" of a message is defined by how many times the underlying script\n   * has finished running (without a compile error) since the message was\n   * last accessed.\n   */\n  public incrementRunCount(maxMessageAge: number): void {\n    this.scriptRunCount += 1\n\n    // It is safe to delete from a map during forEach iteration:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach#Description\n    this.messages.forEach((entry, hash) => {\n      if (entry.getAge(this.scriptRunCount) > maxMessageAge) {\n        logMessage(`Removing expired ForwardMsg [hash=${hash}]`)\n        this.messages.delete(hash)\n      }\n    })\n  }\n\n  /**\n   * Process a ForwardMsg, \"de-referencing\" it if it's a reference to\n   * a cached message.\n   *\n   * - If the message is cacheable, store it in the cache and return it\n   *   unmodified.\n   * - If the message is instead a reference to another message, look for\n   *   the referenced message in the cache, and return it.\n   * - If the referenced message isn't in our cache, request it from the\n   *   server, cache it, and return it.\n   */\n  public async processMessagePayload(\n    msg: ForwardMsg,\n    encodedMsg: Uint8Array\n  ): Promise<ForwardMsg> {\n    this.maybeCacheMessage(msg, encodedMsg)\n\n    if (msg.type !== \"refHash\") {\n      return msg\n    }\n\n    let newMsg = this.getCachedMessage(msg.refHash as string, true)\n    if (newMsg != null) {\n      logMessage(`Cached ForwardMsg HIT [hash=${msg.refHash}]`)\n    } else {\n      // Cache miss: fetch from the server\n      logMessage(`Cached ForwardMsg MISS [hash=${msg.refHash}]`)\n      const encodedNewMsg = await this.endpoints.fetchCachedForwardMsg(\n        msg.refHash as string\n      )\n      try {\n        newMsg = ForwardMsg.decode(encodedNewMsg)\n      } catch (e) {\n        throw new Error(\n          `Failed to decode ForwardMsg (hash=${msg.refHash}): ${\n            ensureError(e).message\n          }`\n        )\n      }\n\n      this.maybeCacheMessage(newMsg, encodedNewMsg)\n    }\n\n    // Copy the metadata from the refMsg into our new message\n    if (!msg.metadata) {\n      throw new Error(\"ForwardMsg has no metadata\")\n    }\n    newMsg.metadata = ForwardMsg.decode(encodedMsg).metadata\n    return newMsg\n  }\n\n  /**\n   * Add a new message to the cache if appropriate.\n   */\n  private maybeCacheMessage(msg: ForwardMsg, encodedMsg: Uint8Array): void {\n    if (msg.type === \"refHash\") {\n      // We never cache reference messages. These messages\n      // may have `metadata.cacheable` set, but this is\n      // only because they carry the metadata for the messages\n      // they refer to.\n      return\n    }\n\n    if (!msg.metadata || !msg.metadata.cacheable) {\n      // Don't cache messages that the server hasn't marked as cacheable.\n      return\n    }\n\n    if (this.getCachedMessage(msg.hash, true) !== undefined) {\n      // We've already cached this message; don't need to do\n      // anything more. (Using getCachedMessage() here ensures\n      // that the message's scriptRunCount value gets updated as\n      // expected.)\n      return\n    }\n\n    logMessage(`Caching ForwardMsg [hash=${msg.hash}]`)\n    this.messages.set(\n      msg.hash,\n      new CacheEntry(encodedMsg, this.scriptRunCount)\n    )\n  }\n\n  /**\n   * Return a new copy of the ForwardMsg with the given hash\n   * from the cache, or undefined if no such message exists.\n   *\n   * If the message's entry exists, its scriptRunCount will be\n   * updated to the current value.\n   */\n  private getCachedMessage(\n    hash: string,\n    updateScriptRunCount: boolean\n  ): ForwardMsg | undefined {\n    const cached = this.messages.get(hash)\n    if (cached == null) {\n      return undefined\n    }\n\n    if (updateScriptRunCount) {\n      cached.scriptRunCount = this.scriptRunCount\n    }\n    return ForwardMsg.decode(cached.encodedMsg)\n  }\n}\n"],"mappings":"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"}