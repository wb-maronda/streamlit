{"version":3,"file":"utils.js","names":["ScriptRunState","getDividerColors","isValidElementId","shouldComponentBeEnabled","elementType","scriptRunState","RUNNING","isElementStale","node","scriptRunId","fragmentIdsThisRun","RERUN_REQUESTED","length","Boolean","fragmentId","includes","isComponentStale","enable","assignDividerColor","theme","allColorMap","allColorKeys","Object","keys","blue","green","orange","red","violet","autoColorMap","autoColorKeys","dividerIndex","Array","from","getElements","forEach","element","divider","heading","type","colorKey","convertKeyToClassName","key","className","trim","replace","getKeyFromId","elementId","undefined","userKey","split","pop"],"sources":["../../../../src/components/core/Block/utils.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppNode, BlockNode } from \"@streamlit/lib/src/AppNode\"\nimport { ComponentRegistry } from \"@streamlit/lib/src/components/widgets/CustomComponent\"\nimport { FileUploadClient } from \"@streamlit/lib/src/FileUploadClient\"\nimport { ScriptRunState } from \"@streamlit/lib/src/ScriptRunState\"\nimport { SessionInfo } from \"@streamlit/lib/src/SessionInfo\"\nimport { StreamlitEndpoints } from \"@streamlit/lib/src/StreamlitEndpoints\"\nimport { EmotionTheme, getDividerColors } from \"@streamlit/lib/src/theme\"\nimport { isValidElementId } from \"@streamlit/lib/src/util/utils\"\nimport {\n  FormsData,\n  WidgetStateManager,\n} from \"@streamlit/lib/src/WidgetStateManager\"\n\nexport function shouldComponentBeEnabled(\n  elementType: string,\n  scriptRunState: ScriptRunState\n): boolean {\n  return elementType !== \"empty\" || scriptRunState !== ScriptRunState.RUNNING\n}\n\nexport function isElementStale(\n  node: AppNode,\n  scriptRunState: ScriptRunState,\n  scriptRunId: string,\n  fragmentIdsThisRun?: Array<string>\n): boolean {\n  if (scriptRunState === ScriptRunState.RERUN_REQUESTED) {\n    // If a rerun was just requested, all of our current elements\n    // are about to become stale.\n    return true\n  }\n\n  if (scriptRunState === ScriptRunState.RUNNING) {\n    if (fragmentIdsThisRun && fragmentIdsThisRun.length) {\n      // if the fragmentId is set, we only want to mark elements as stale\n      // that belong to the same fragmentId and have a different scriptRunId.\n      // If they have the same scriptRunId, they were just updated.\n      return Boolean(\n        node.fragmentId &&\n          fragmentIdsThisRun.includes(node.fragmentId) &&\n          node.scriptRunId !== scriptRunId\n      )\n    }\n    return node.scriptRunId !== scriptRunId\n  }\n\n  return false\n}\n\nexport function isComponentStale(\n  enable: boolean,\n  node: AppNode,\n  scriptRunState: ScriptRunState,\n  scriptRunId: string,\n  fragmentIdsThisRun?: Array<string>\n): boolean {\n  return (\n    !enable ||\n    isElementStale(node, scriptRunState, scriptRunId, fragmentIdsThisRun)\n  )\n}\n\nexport function assignDividerColor(\n  node: BlockNode,\n  theme: EmotionTheme\n): void {\n  // All available divider colors\n  const allColorMap = getDividerColors(theme)\n  const allColorKeys = Object.keys(allColorMap)\n\n  // Limited colors for auto assignment\n  const { blue, green, orange, red, violet } = allColorMap\n  const autoColorMap = { blue, green, orange, red, violet }\n  const autoColorKeys = Object.keys(autoColorMap)\n  let dividerIndex = 0\n\n  Array.from(node.getElements()).forEach(element => {\n    const divider = element.heading?.divider\n    if (element.type === \"heading\" && divider) {\n      if (divider === \"auto\") {\n        const colorKey = autoColorKeys[dividerIndex]\n        // @ts-expect-error - heading.divider is not undefined at this point\n        element.heading.divider = autoColorMap[colorKey]\n        dividerIndex += 1\n        if (dividerIndex === autoColorKeys.length) dividerIndex = 0\n      } else if (allColorKeys.includes(divider)) {\n        // @ts-expect-error\n        element.heading.divider = allColorMap[divider]\n      }\n    }\n  })\n}\nexport interface BaseBlockProps {\n  /**\n   * The app's StreamlitEndpoints instance. Exposes non-websocket endpoint logic\n   * used by various Streamlit elements.\n   */\n  endpoints: StreamlitEndpoints\n\n  /**\n   * The app's SessionInfo instance. Exposes session-specific properties.\n   */\n  sessionInfo: SessionInfo\n\n  /**\n   * The app's WidgetStateManager instance. Used by all widget elements to\n   * store and retrieve widget state. When the user interacts with a widget,\n   * the WidgetStateManager initiates the \"rerun BackMsg\" data flow to kick\n   * off a script rerun.\n   */\n  widgetMgr: WidgetStateManager\n\n  /**\n   * The app's FileUploadClient instance. Used by the FileUploader component\n   * to send files to the Streamlit backend.\n   */\n  uploadClient: FileUploadClient\n\n  /**\n   * The app's ComponentRegistry instance. Dispatches \"Custom Component\"\n   * iframe messages to ComponentInstances.\n   */\n  componentRegistry: ComponentRegistry\n\n  /**\n   * The ID of the current \"script run\". When a Streamlit script is re-run\n   * (usually as a result of the user interacting with a widget), the Streamlit\n   * backend sends a new scriptRunId to the frontend. When the script run ends,\n   * the frontend discards \"stale\" elements (that is, elements with a non-current\n   * scriptRunId).\n   */\n  scriptRunId: string\n\n  /**\n   * The app's current ScriptRunState. This is used in combination with\n   * scriptRunId to prune stale elements. It's also used by the app to\n   * display the \"running man\" indicator when the app's script is being re-run.\n   */\n  scriptRunState: ScriptRunState\n\n  /**\n   * If true, all widgets will be disabled and the app will be non-interactive.\n   * This is generally set when the frontend is disconnected from the backend.\n   */\n  widgetsDisabled: boolean\n\n  /**\n   * Data about all forms in the app. The WidgetStateManager creates its own\n   * internal FormsData instance, and calls a callback (`formsDataChanged`)\n   * when forms are updated. This FormsData instance should be updated\n   * from that callback.\n   */\n  formsData: FormsData\n\n  /**\n   * If true , the element should not allow going into fullscreen. Right now we plan\n   * to use it, for example, in Dialogs to prevent fullscreen issues.\n   */\n  disableFullscreenMode?: boolean\n}\n\n/**\n * Converts a user-specified key to a valid CSS class name.\n *\n * @param key - The key to convert.\n * @returns A valid CSS class name.\n */\nexport function convertKeyToClassName(key: string | undefined | null): string {\n  if (!key) {\n    return \"\"\n  }\n  const className = key.trim().replace(/[^a-zA-Z0-9_-]/g, \"-\")\n  return \"st-key-\" + className\n}\n\n/**\n * Returns the user-specified key extracted from the element id, or undefined if the id does\n * not have a user-specified key.\n */\nexport function getKeyFromId(\n  elementId: string | undefined | null\n): string | undefined {\n  if (!elementId || !isValidElementId(elementId)) {\n    return undefined\n  }\n\n  const userKey = elementId.split(\"-\", 3).pop()\n  return userKey === \"None\" ? undefined : userKey\n}\n"],"mappings":"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"}