{"version":3,"file":"withMapboxToken.js","names":["React","PureComponent","hoistNonReactStatics","axios","ensureError","Skeleton","SkeletonProto","LibContext","MapboxTokenError","jsx","_jsx","MapboxTokenNotProvidedError","Error","MapboxTokenFetchingError","TOKENS_URL","MAPBOX","withMapboxToken","deltaType","WrappedComponent","WithMapboxToken","constructor","props","context","initMapboxToken","response","get","token","data","setState","mapboxToken","isFetching","e","error","mapboxTokenError","message","render","state","width","element","create","style","SkeletonStyle","ELEMENT","undefined","componentDidMount","libConfig","displayName","name","contextType"],"sources":["../../../../../src/components/elements/DeckGlJsonChart/withMapboxToken/withMapboxToken.tsx"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ComponentType, PureComponent, ReactNode } from \"react\"\n\nimport hoistNonReactStatics from \"hoist-non-react-statics\"\nimport axios from \"axios\"\n\nimport { ensureError } from \"@streamlit/lib/src/util/ErrorHandling\"\nimport {\n  DeckGlJsonChart,\n  Skeleton as SkeletonProto,\n} from \"@streamlit/lib/src/proto\"\nimport { Skeleton } from \"@streamlit/lib/src/components/elements/Skeleton\"\nimport { LibContext } from \"@streamlit/lib/src/components/core/LibContext\"\n\nimport MapboxTokenError from \"./MapboxTokenError\"\n\ninterface InjectedProps {\n  mapboxToken: string\n}\n\nexport interface State {\n  mapboxToken?: string\n  mapboxTokenError?: Error\n  isFetching: boolean\n}\n\n// Wraps a Component expecting a \"mapboxToken\" prop.\n// The wrapped Component accepts a DeckGLJsonChart prop, which\n// incorporates the config.toml token (if provided) and omits the \"mapboxToken\" prop.\nexport type WrappedMapboxProps<P extends InjectedProps> = Omit<\n  P,\n  \"mapboxToken\"\n> & {\n  element: DeckGlJsonChart\n  width: number\n}\n\nexport class MapboxTokenNotProvidedError extends Error {}\nexport class MapboxTokenFetchingError extends Error {}\n\n/**\n * A remote file that stores user-visible tokens.\n */\nexport const TOKENS_URL = \"https://data.streamlit.io/tokens.json\"\nconst MAPBOX = \"mapbox\"\n\n/**\n * A higher-order component that fetches our mapbox token and passes\n * it through to the wrapped component.\n * This component uses tokens from config.toml first when available.\n * If the token fetch fails, an error will be rendered in place of the wrapped component.\n * This component is necessary as it's good practice to separate data collection\n * (mapbox token retrieval) and the actual rendering of a component.\n *\n * @param {string} deltaType In case of an exception we show an error with this\n */\n\nconst withMapboxToken =\n  (deltaType: string) =>\n  <P extends InjectedProps>(\n    WrappedComponent: ComponentType<React.PropsWithChildren<P>>\n  ) => {\n    // Return a wrapper that accepts the wrapped component's props, minus\n    // \"mapboxToken\". The wrapper will fetch the mapboxToken and inject it into\n    // the wrapped component automatically.\n    class WithMapboxToken extends PureComponent<WrappedMapboxProps<P>, State> {\n      public static readonly displayName = `withMapboxToken(${\n        WrappedComponent.displayName || WrappedComponent.name\n      })`\n\n      static contextType = LibContext\n\n      context!: React.ContextType<typeof LibContext>\n\n      public constructor(props: WrappedMapboxProps<P>) {\n        super(props)\n\n        this.state = {\n          isFetching: true,\n          mapboxToken: undefined,\n          mapboxTokenError: undefined,\n        }\n      }\n\n      /**\n       * Fetch the remote \"tokens.json\" set the \"mapbox\" in state.\n       * Throw an error if we can't contact TOKENS_URL or the token is missing.\n       */\n      public initMapboxToken = async (): Promise<void> => {\n        try {\n          const response = await axios.get(TOKENS_URL)\n          const { [MAPBOX]: token } = response.data\n\n          if (!token) {\n            throw new Error(`Missing token ${MAPBOX}`)\n          }\n\n          this.setState({\n            mapboxToken: token,\n            isFetching: false,\n          })\n        } catch (e) {\n          const error = ensureError(e)\n\n          this.setState({\n            mapboxTokenError: error,\n            isFetching: false,\n          })\n          throw new MapboxTokenFetchingError(\n            `${error.message} (${TOKENS_URL})`\n          )\n        }\n      }\n\n      public componentDidMount(): void {\n        const mapboxToken =\n          this.props.element.mapboxToken || this.context.libConfig.mapboxToken\n\n        if (mapboxToken) {\n          this.setState({\n            mapboxToken,\n            isFetching: false,\n          })\n        } else {\n          this.initMapboxToken()\n        }\n      }\n\n      public render = (): ReactNode => {\n        const { mapboxToken, mapboxTokenError, isFetching } = this.state\n        const { width } = this.props\n\n        // We got an error when fetching our mapbox token: show the error.\n        if (mapboxTokenError) {\n          return (\n            <MapboxTokenError\n              width={width}\n              error={mapboxTokenError}\n              deltaType={deltaType}\n            />\n          )\n        }\n\n        // If our mapboxToken hasn't been retrieved yet, show a loading\n        // skeleton.\n        if (isFetching) {\n          return (\n            <Skeleton\n              element={SkeletonProto.create({\n                style: SkeletonProto.SkeletonStyle.ELEMENT,\n              })}\n            />\n          )\n        }\n\n        // We have the mapbox token. Pass it through to our component.\n        return (\n          // (this.props as unknown as P) is required to work around a TS issue:\n          // https://github.com/microsoft/TypeScript/issues/28938#issuecomment-450636046\n          <WrappedComponent\n            {...(this.props as unknown as P)}\n            mapboxToken={mapboxToken}\n            width={width}\n          />\n        )\n      }\n    }\n\n    return hoistNonReactStatics(WithMapboxToken, WrappedComponent)\n  }\n\nexport default withMapboxToken\n"],"mappings":"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"}