{"version":3,"file":"Audio.js","names":["React","useEffect","useRef","useMemo","jsx","_jsx","Audio","_ref","element","width","endpoints","elementMgr","audioRef","startTime","endTime","loop","autoplay","preventAutoplay","id","getElementState","setElementState","current","currentTime","audioNode","setStartTime","addEventListener","removeEventListener","stoppedByEndTime","handleTimeUpdate","play","pause","handleAudioEnd","uri","buildMediaURL","url","ref","controls","autoPlay","src","className","style"],"sources":["../../../../src/components/elements/Audio/Audio.tsx"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ReactElement, useEffect, useRef, useMemo } from \"react\"\nimport { Audio as AudioProto } from \"@streamlit/lib/src/proto\"\nimport { StreamlitEndpoints } from \"@streamlit/lib/src/StreamlitEndpoints\"\nimport { WidgetStateManager as ElementStateManager } from \"@streamlit/lib/src/WidgetStateManager\"\n\nexport interface AudioProps {\n  endpoints: StreamlitEndpoints\n  width: number\n  element: AudioProto\n  elementMgr: ElementStateManager\n}\n\nexport default function Audio({\n  element,\n  width,\n  endpoints,\n  elementMgr,\n}: AudioProps): ReactElement {\n  const audioRef = useRef<HTMLAudioElement>(null)\n\n  const { startTime, endTime, loop, autoplay } = element\n\n  const preventAutoplay = useMemo<boolean>(() => {\n    if (!element.id) {\n      // Elements without an ID should never autoplay\n      return true\n    }\n\n    // Recover the state in case this component got unmounted\n    // and mounted again for the same element.\n    const preventAutoplay = elementMgr.getElementState(\n      element.id,\n      \"preventAutoplay\"\n    )\n\n    if (!preventAutoplay) {\n      // Set the state to prevent autoplay in case there is an unmount + mount\n      // for the same element.\n      elementMgr.setElementState(element.id, \"preventAutoplay\", true)\n    }\n    return preventAutoplay ?? false\n  }, [element.id, elementMgr])\n\n  // Handle startTime changes\n  useEffect(() => {\n    if (audioRef.current) {\n      audioRef.current.currentTime = startTime\n    }\n  }, [startTime])\n\n  useEffect(() => {\n    const audioNode = audioRef.current\n\n    const setStartTime: () => void = () => {\n      if (audioNode) {\n        // setStartTime\n        audioNode.currentTime = element.startTime\n      }\n    }\n\n    if (audioNode) {\n      audioNode.addEventListener(\"loadedmetadata\", setStartTime)\n    }\n\n    return () => {\n      if (audioNode) {\n        audioNode.removeEventListener(\"loadedmetadata\", setStartTime)\n      }\n    }\n  }, [element])\n\n  // Stop the audio at 'endTime' and handle loop\n  useEffect(() => {\n    const audioNode = audioRef.current\n    if (!audioNode) return\n\n    // Flag to avoid calling 'audioNode.pause()' multiple times\n    let stoppedByEndTime = false\n\n    const handleTimeUpdate = (): void => {\n      if (endTime > 0 && audioNode.currentTime >= endTime) {\n        if (loop) {\n          // If loop is true and we reached 'endTime', reset to 'startTime'\n          audioNode.currentTime = startTime || 0\n          audioNode.play()\n        } else if (!stoppedByEndTime) {\n          stoppedByEndTime = true\n          audioNode.pause()\n        }\n      }\n    }\n\n    if (endTime > 0) {\n      audioNode.addEventListener(\"timeupdate\", handleTimeUpdate)\n    }\n\n    return () => {\n      if (audioNode && endTime > 0) {\n        audioNode.removeEventListener(\"timeupdate\", handleTimeUpdate)\n      }\n    }\n  }, [endTime, loop, startTime])\n\n  // Handle looping the audio\n  useEffect(() => {\n    const audioNode = audioRef.current\n    if (!audioNode) return\n\n    // Loop the audio when it has ended\n    const handleAudioEnd = (): void => {\n      if (loop) {\n        audioNode.currentTime = startTime || 0 // Reset to startTime or to the start if not specified\n        audioNode.play()\n      }\n    }\n\n    audioNode.addEventListener(\"ended\", handleAudioEnd)\n\n    return () => {\n      if (audioNode) {\n        audioNode.removeEventListener(\"ended\", handleAudioEnd)\n      }\n    }\n  }, [loop, startTime])\n\n  const uri = endpoints.buildMediaURL(element.url)\n\n  return (\n    <audio\n      data-testid=\"stAudio\"\n      id=\"audio\"\n      ref={audioRef}\n      controls\n      autoPlay={autoplay && !preventAutoplay}\n      src={uri}\n      className=\"stAudio\"\n      style={{ width }}\n    />\n  )\n}\n"],"mappings":"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"}