{"version":3,"file":"EditingState.js","names":["notNullOrUndefined","isNullOrUndefined","isMissingValueCell","INDEX_IDENTIFIER","getColumnName","column","isIndex","name","EditingState","constructor","numRows","editedCells","Map","addedRows","deletedRows","toJson","columns","columnsByIndex","forEach","set","indexNumber","currentState","edited_rows","added_rows","deleted_rows","row","rowIndex","_map","editedRow","cell","colIndex","get","getCellValue","addedRow","isIncomplete","cellValue","isRequired","isEditable","push","json","JSON","stringify","_k","v","undefined","fromJson","editingStateJson","editingState","parse","columnsByName","Object","keys","key","Number","colName","getCell","_this$editedCells$get","has","isAddedRow","col","rowCache","setCell","length","addRow","rowCells","deleteRows","rows","sort","a","b","deleteRow","splice","includes","delete","getOriginalRowIndex","originalIndex","i","getNumRows"],"sources":["../../../../src/components/widgets/DataFrame/EditingState.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GridCell } from \"@glideapps/glide-data-grid\"\n\nimport {\n  notNullOrUndefined,\n  isNullOrUndefined,\n} from \"@streamlit/lib/src/util/utils\"\n\nimport { BaseColumn, isMissingValueCell } from \"./columns\"\nimport { INDEX_IDENTIFIER } from \"./hooks/useColumnLoader\"\n\n/**\n * Get the column name for a given column to use in the widget state.\n * This is either the column name or the index identifier for index columns.\n */\nexport function getColumnName(column: BaseColumn): string {\n  // TODO(lukasmasuch): We need to adapt this once we want to support multi-index columns.\n  return column.isIndex\n    ? INDEX_IDENTIFIER\n    : isNullOrUndefined(column.name)\n    ? \"\"\n    : column.name\n}\n\n/**\n * The editing state keeps track of all table edits applied by the user.\n */\nclass EditingState {\n  // row -> column -> GridCell\n  // Using [number, number] as a key for a Map would not work.\n  private editedCells: Map<number, Map<number, GridCell>> = new Map()\n\n  // List of rows represented by of column -> GridCell mappings\n  private addedRows: Array<Map<number, GridCell>> = []\n\n  // List of deleted row IDs\n  private deletedRows: number[] = []\n\n  // The original number of rows in the table (without potential additions & deletions)\n  private numRows = 0\n\n  constructor(numRows: number) {\n    this.numRows = numRows\n  }\n\n  /**\n   * Convert the current editing state to a JSON string.\n   *\n   * @param columns - The columns of the table\n   * @returns JSON string\n   */\n  toJson(columns: BaseColumn[]): string {\n    const columnsByIndex = new Map<number, BaseColumn>()\n    columns.forEach(column => {\n      columnsByIndex.set(column.indexNumber, column)\n    })\n\n    const currentState = {\n      // We use snake case here since this is the widget state\n      // that is sent and used in the backend. Therefore, it should\n      // conform with the Python naming conventions.\n      edited_rows: {} as Record<number, Record<string, any>>,\n      added_rows: [] as Record<string, any>[],\n      deleted_rows: [] as number[],\n    }\n\n    // Loop through all edited cells and transform into the structure\n    // we use for the JSON-compatible widget state:\n    // row position -> column name -> edited value\n    this.editedCells.forEach(\n      (row: Map<number, GridCell>, rowIndex: number, _map) => {\n        const editedRow: Record<string, any> = {}\n        row.forEach((cell: GridCell, colIndex: number, _map) => {\n          const column = columnsByIndex.get(colIndex)\n          if (column) {\n            editedRow[getColumnName(column)] = column.getCellValue(cell)\n          }\n        })\n        currentState.edited_rows[rowIndex] = editedRow\n      }\n    )\n\n    // Loop through all added rows and transform into the format that\n    // we use for the JSON-compatible widget state:\n    // List of column name -> edited value\n    this.addedRows.forEach((row: Map<number, GridCell>) => {\n      const addedRow: Record<string, any> = {}\n      // This flags is used to check if the row is incomplete\n      // (i.e. missing required values) and should therefore not be included in\n      // the current state version.\n      let isIncomplete = false\n      row.forEach((cell: GridCell, colIndex: number, _map) => {\n        const column = columnsByIndex.get(colIndex)\n        if (column) {\n          const cellValue = column.getCellValue(cell)\n\n          if (\n            column.isRequired &&\n            column.isEditable &&\n            isMissingValueCell(cell)\n          ) {\n            // If the cell is missing a required value, the row is incomplete\n            isIncomplete = true\n          }\n\n          if (notNullOrUndefined(cellValue)) {\n            addedRow[getColumnName(column)] = cellValue\n          }\n        }\n      })\n      if (!isIncomplete) {\n        currentState.added_rows.push(addedRow)\n      }\n    })\n\n    // The deleted rows don't need to be transformed\n    currentState.deleted_rows = this.deletedRows\n\n    // Convert undefined values to null, otherwise this is removed here since\n    // undefined does not exist in JSON.\n    const json = JSON.stringify(currentState, (_k, v) =>\n      v === undefined ? null : v\n    )\n    return json\n  }\n\n  /**\n   * Load the editing state from a JSON string.\n   *\n   * @param columns - The columns of the table\n   * @returns JSON string\n   */\n  fromJson(editingStateJson: string, columns: BaseColumn[]): void {\n    // Clear existing state:\n    this.editedCells = new Map()\n    this.addedRows = []\n    this.deletedRows = []\n\n    // Parse JSON editing string:\n    const editingState = JSON.parse(editingStateJson)\n    // Map columns to column index\n    const columnsByIndex = new Map<number, BaseColumn>()\n    columns.forEach(column => {\n      columnsByIndex.set(column.indexNumber, column)\n    })\n\n    // Map column name to columns\n    const columnsByName = new Map<string, BaseColumn>()\n    columns.forEach(column => {\n      columnsByName.set(getColumnName(column), column)\n    })\n\n    // Loop through all edited cells and transform into the structure\n    // we use for the editing state:\n    // row -> column -> GridCell\n    Object.keys(editingState.edited_rows).forEach(key => {\n      const rowIndex = Number(key)\n      const editedRow = editingState.edited_rows[key]\n      Object.keys(editedRow).forEach((colName: string) => {\n        const cellValue = editedRow[colName]\n        const column = columnsByName.get(colName)\n        if (column) {\n          const cell = column.getCell(cellValue)\n          if (cell) {\n            if (!this.editedCells.has(rowIndex)) {\n              this.editedCells.set(rowIndex, new Map())\n            }\n            this.editedCells.get(rowIndex)?.set(column.indexNumber, cell)\n          }\n        }\n      })\n    })\n\n    // Loop through all added rows and transform into the format that\n    // we use for the editing state:\n    // List of column index -> edited value\n    editingState.added_rows.forEach((row: Record<string, any>) => {\n      const addedRow: Map<number, GridCell> = new Map()\n      // Initialize all columns with null (empty) values first\n      // This is necessary to ensure that all columns are present in the added row.\n      // We will overwrite the empty values with the actual values below\n      // if the actual value exists. We need to do this since we are only\n      // putting none-empty values in the widget state for optimization reasons.\n      columns.forEach(column => {\n        addedRow.set(column.indexNumber, column.getCell(null))\n      })\n\n      // Set the cells that were actually edited in the row\n      Object.keys(row).forEach(colName => {\n        const cellValue = row[colName]\n\n        const column = columnsByName.get(colName)\n\n        if (column) {\n          const cell = column.getCell(cellValue)\n          if (cell) {\n            addedRow.set(column.indexNumber, cell)\n          }\n        }\n      })\n      this.addedRows.push(addedRow)\n    })\n\n    // The deleted rows don't need to be transformed\n    this.deletedRows = editingState.deleted_rows\n  }\n\n  /**\n   * Returns true if the given row was added by the user through the UI.\n   */\n  isAddedRow(row: number): boolean {\n    return row >= this.numRows\n  }\n\n  /**\n   * Returns the cell at the given column and row,\n   * in case the cell was edited or added.\n   *\n   * @param col - The column index\n   * @param row - The row index\n   *\n   * @returns The edited cell at the given column and row\n   */\n  getCell(col: number, row: number): GridCell | undefined {\n    if (this.isAddedRow(row)) {\n      // Added rows have their own editing state\n      return this.addedRows[row - this.numRows].get(col)\n    }\n\n    const rowCache = this.editedCells.get(row)\n    if (rowCache === undefined) {\n      return undefined\n    }\n\n    return rowCache.get(col)\n  }\n\n  /**\n   * Adds a cell to the editing state for the given column and row index.\n   *\n   * @param col - The column index\n   * @param row - The row index\n   * @param cell - The cell to add to the editing state\n   */\n  setCell(col: number, row: number, cell: GridCell): void {\n    if (this.isAddedRow(row)) {\n      if (row - this.numRows >= this.addedRows.length) {\n        // Added row does not exist. This is only expected to happen\n        // in relation to a trailing row issue in glide-data-grid.\n        return\n      }\n      // Added rows have their own editing state\n      this.addedRows[row - this.numRows].set(col, cell)\n    } else {\n      if (this.editedCells.get(row) === undefined) {\n        this.editedCells.set(row, new Map())\n      }\n\n      const rowCache = this.editedCells.get(row) as Map<number, GridCell>\n      rowCache.set(col, cell)\n    }\n  }\n\n  /**\n   * Adds a new row to the editing state.\n   *\n   * @param rowCells - The cells of the row to add\n   */\n  addRow(rowCells: Map<number, GridCell>): void {\n    this.addedRows.push(rowCells)\n  }\n\n  /**\n   * Deletes the given rows from the editing state.\n   *\n   * @param rows - The rows to delete\n   */\n  deleteRows(rows: number[]): void {\n    // Delete row one by one starting from the row with the highest index\n    rows\n      .sort((a, b) => b - a)\n      .forEach(row => {\n        this.deleteRow(row)\n      })\n  }\n\n  /**\n   * Deletes the given row from the editing state.\n   *\n   * @param row - The row to delete\n   */\n  deleteRow(row: number): void {\n    if (isNullOrUndefined(row) || row < 0) {\n      // This should never happen\n      return\n    }\n\n    if (this.isAddedRow(row)) {\n      // Remove from added rows:\n      this.addedRows.splice(row - this.numRows, 1)\n      // there is nothing more we have to do\n      return\n    }\n\n    if (!this.deletedRows.includes(row)) {\n      // Add to the set\n      this.deletedRows.push(row)\n      // Sort the deleted rows (important for calculation of the original row index)\n      this.deletedRows = this.deletedRows.sort((a, b) => a - b)\n    }\n\n    // Remove all cells from cell state associated with this row:\n    this.editedCells.delete(row)\n  }\n\n  /**\n   * Returns the original row index of the given row.\n   * Since the user can delete rows, the original row index and the\n   * current one can diverge.\n   *\n   * @param row - The row index from the current state\n   *\n   * @returns The original row index\n   */\n  getOriginalRowIndex(row: number): number {\n    // Just count all deleted rows before this row to determine the original row index:\n    let originalIndex = row\n    for (let i = 0; i < this.deletedRows.length; i++) {\n      if (this.deletedRows[i] > originalIndex) {\n        break\n      }\n      originalIndex += 1\n    }\n    return originalIndex\n  }\n\n  /**\n   * Returns the total number of rows of the current state.\n   */\n  getNumRows(): number {\n    return this.numRows + this.addedRows.length - this.deletedRows.length\n  }\n}\n\nexport default EditingState\n"],"mappings":"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"}