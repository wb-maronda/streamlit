{"version":3,"file":"useDataEditor.js","names":["React","logWarning","notNullOrUndefined","isErrorCell","useDataEditor","columns","fixedNumRows","editingState","getCellContent","getOriginalIndex","refreshCells","updateNumRows","syncEditState","clearSelection","onCellEdited","useCallback","_ref","updatedCell","col","row","column","isEditable","originalCol","indexNumber","originalRow","current","getOriginalRowIndex","currentCell","currentValue","getCellValue","newValue","newCell","getCell","setCell","lastUpdated","performance","now","data","appendEmptyRow","newRow","Map","forEach","set","defaultValue","addRow","onRowAppended","onDelete","selection","rows","length","rowsToDelete","toArray","map","deleteRows","range","updatedCells","selectedArea","y","height","x","width","isRequired","push","cell","onPaste","target","values","targetCol","targetRow","rowData","getNumRows","pasteDataValue","rowIndex","colIndex","validateCell","validateInput","validationResult"],"sources":["../../../../../src/components/widgets/DataFrame/hooks/useDataEditor.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React from \"react\"\n\nimport {\n  DataEditorProps,\n  EditableGridCell,\n  GridCell,\n  GridSelection,\n  Item,\n  ValidatedGridCell,\n} from \"@glideapps/glide-data-grid\"\n\nimport { logWarning } from \"@streamlit/lib/src/util/log\"\nimport { notNullOrUndefined } from \"@streamlit/lib/src/util/utils\"\nimport {\n  BaseColumn,\n  isErrorCell,\n} from \"@streamlit/lib/src/components/widgets/DataFrame/columns\"\nimport EditingState from \"@streamlit/lib/src/components/widgets/DataFrame/EditingState\"\n\n/**\n * Create return type for useDataLoader hook based on the DataEditorProps.\n */\ntype DataEditorReturn = Pick<\n  DataEditorProps,\n  \"onCellEdited\" | \"onPaste\" | \"onRowAppended\" | \"onDelete\" | \"validateCell\"\n>\n\n/**\n * Custom hook to handle all aspects related to data editing. This includes editing cells,\n * pasting from clipboard, and appending & deleting rows.\n *\n * @param columns - The columns of the table.\n * @param fixedNumRows - Whether the number of rows is fixed. This means that rows cannot be added or deleted.\n * @param editingState - The editing state of the data editor.\n * @param getCellContent - Function to get a specific cell.\n * @param getOriginalIndex - Function to map a row ID of the current state to the original row ID.\n *                           This mainly changed by sorting of columns.\n * @param updateNumRows - Callback to sync the number of rows from editing state with the component state.\n * @param refreshCells - Callback that allows to trigger a UI refresh of a selection of cells.\n * @param syncEditState - Callback that needs to be called on all edits. This will also trigger a rerun\n *                     and send widget state to the backend.\n *\n * @returns Glide-data-grid compatible functions for editing capabilities.\n */\nfunction useDataEditor(\n  columns: BaseColumn[],\n  fixedNumRows: boolean,\n  editingState: React.MutableRefObject<EditingState>,\n  getCellContent: ([col, row]: readonly [number, number]) => GridCell,\n  getOriginalIndex: (index: number) => number,\n  refreshCells: (\n    cells: {\n      cell: [number, number]\n    }[]\n  ) => void,\n  updateNumRows: () => void,\n  syncEditState: () => void,\n  clearSelection: () => void\n): DataEditorReturn {\n  const onCellEdited = React.useCallback(\n    (\n      [col, row]: readonly [number, number],\n      updatedCell: EditableGridCell\n    ): void => {\n      const column = columns[col]\n\n      if (!column.isEditable) {\n        return\n      }\n\n      const originalCol = column.indexNumber\n\n      // We need to apply two different mappings here. One for the case that\n      // the user has sorted a column, and another one from the editing state\n      // to get the correct row ID when the user has deleted rows.\n      const originalRow = editingState.current.getOriginalRowIndex(\n        getOriginalIndex(row)\n      )\n      const currentCell = getCellContent([col, row])\n      const currentValue = column.getCellValue(currentCell)\n      const newValue = column.getCellValue(updatedCell)\n      if (!isErrorCell(currentCell) && newValue === currentValue) {\n        // No editing is required since the values did not change\n        return\n      }\n\n      const newCell = column.getCell(newValue, true)\n      // Only update the cell if the new cell is not causing any errors:\n      if (!isErrorCell(newCell)) {\n        editingState.current.setCell(originalCol, originalRow, {\n          ...newCell,\n          lastUpdated: performance.now(),\n        })\n\n        syncEditState()\n      } else {\n        logWarning(\n          `Not applying the cell edit since it causes this error:\\n ${newCell.data}`\n        )\n      }\n    },\n    [columns, editingState, getOriginalIndex, getCellContent, syncEditState]\n  )\n\n  /**\n   * Appends a new empty row to the end of the table.\n   */\n  const appendEmptyRow = React.useCallback(() => {\n    if (fixedNumRows) {\n      // Appending rows is not supported\n      return\n    }\n\n    const newRow: Map<number, GridCell> = new Map()\n    columns.forEach(column => {\n      // For the default value, we trust the developer to make a valid choice,\n      // so we do not validate the value here.\n      newRow.set(column.indexNumber, column.getCell(column.defaultValue))\n    })\n    editingState.current.addRow(newRow)\n    updateNumRows()\n  }, [columns, editingState, fixedNumRows, updateNumRows])\n\n  /**\n   * Callback used by glide-data-grid when the user adds a new row in the table UI.\n   */\n  const onRowAppended = React.useCallback(() => {\n    if (fixedNumRows) {\n      // Appending rows is not supported\n      return\n    }\n\n    appendEmptyRow()\n    syncEditState()\n  }, [appendEmptyRow, syncEditState, fixedNumRows])\n\n  /**\n   * Callback used by glide-data-grid when the user deletes a row or cell value in the table UI.\n   */\n  const onDelete = React.useCallback(\n    (selection: GridSelection): GridSelection | boolean => {\n      if (selection.rows.length > 0) {\n        // User has selected one or more rows\n        if (fixedNumRows) {\n          // Deleting rows is not supported\n          return true\n        }\n\n        const rowsToDelete = selection.rows.toArray().map(row => {\n          return editingState.current.getOriginalRowIndex(\n            getOriginalIndex(row)\n          )\n        })\n        // We need to delete all rows at once, so that the indexes work correct\n        editingState.current.deleteRows(rowsToDelete)\n        updateNumRows()\n        clearSelection()\n        syncEditState()\n        return false\n      }\n      if (selection.current?.range) {\n        // User has selected one or more cells\n        const updatedCells: { cell: [number, number] }[] = []\n        const selectedArea = selection.current.range\n        for (\n          let row = selectedArea.y;\n          row < selectedArea.y + selectedArea.height;\n          row++\n        ) {\n          for (\n            let col = selectedArea.x;\n            col < selectedArea.x + selectedArea.width;\n            col++\n          ) {\n            const column = columns[col]\n            // Only allow deletion if the column is editable and not configured as required\n            if (column.isEditable && !column.isRequired) {\n              updatedCells.push({\n                cell: [col, row],\n              })\n              onCellEdited(\n                [col, row],\n                column.getCell(null) as EditableGridCell\n              )\n            }\n          }\n        }\n\n        if (updatedCells.length > 0) {\n          syncEditState()\n          refreshCells(updatedCells)\n        }\n        return false\n      }\n      return true\n    },\n    [\n      columns,\n      editingState,\n      fixedNumRows,\n      refreshCells,\n      getOriginalIndex,\n      syncEditState,\n      onCellEdited,\n      clearSelection,\n      updateNumRows,\n    ]\n  )\n\n  /**\n   * Callback used by glide-data-grid when the user pastes data into the table.\n   */\n  const onPaste = React.useCallback(\n    (target: Item, values: readonly (readonly string[])[]): boolean => {\n      const [targetCol, targetRow] = target\n\n      const updatedCells: { cell: [number, number] }[] = []\n\n      for (let row = 0; row < values.length; row++) {\n        const rowData = values[row]\n        if (row + targetRow >= editingState.current.getNumRows()) {\n          if (fixedNumRows) {\n            // Only add new rows if editing mode is dynamic, otherwise break here\n            break\n          }\n          // Adding rows during paste would not work currently. However, we already disallow\n          // sorting in dynamic mode, so we don't have to do anything here.\n          appendEmptyRow()\n        }\n        for (let col = 0; col < rowData.length; col++) {\n          const pasteDataValue = rowData[col]\n\n          const rowIndex = row + targetRow\n          const colIndex = col + targetCol\n\n          if (colIndex >= columns.length) {\n            // We could potentially add new columns here in the future.\n            break\n          }\n\n          const column = columns[colIndex]\n          // Only add to columns that are editable:\n          if (column.isEditable) {\n            const newCell = column.getCell(pasteDataValue, true)\n\n            // We are not editing cells if the pasted value leads to an error:\n            if (notNullOrUndefined(newCell) && !isErrorCell(newCell)) {\n              const originalCol = column.indexNumber\n              const originalRow = editingState.current.getOriginalRowIndex(\n                getOriginalIndex(rowIndex)\n              )\n              const currentValue = column.getCellValue(\n                getCellContent([colIndex, rowIndex])\n              )\n              const newValue = column.getCellValue(newCell)\n              // Edit the cell only if the value actually changed:\n              if (newValue !== currentValue) {\n                editingState.current.setCell(originalCol, originalRow, {\n                  ...newCell,\n                  lastUpdated: performance.now(),\n                })\n\n                updatedCells.push({\n                  cell: [colIndex, rowIndex],\n                })\n              }\n            }\n          }\n        }\n\n        if (updatedCells.length > 0) {\n          syncEditState()\n          refreshCells(updatedCells)\n        }\n      }\n\n      return false\n    },\n    [\n      columns,\n      editingState,\n      fixedNumRows,\n      getOriginalIndex,\n      getCellContent,\n      appendEmptyRow,\n      syncEditState,\n      refreshCells,\n    ]\n  )\n\n  /**\n   * Callback used by glide-data-grid to validate the data inputted into a cell by the user.\n   */\n  const validateCell = React.useCallback(\n    (cell: Item, newValue: EditableGridCell) => {\n      const col = cell[0]\n      if (col >= columns.length) {\n        // This should never happen.\n        // But we return true (default) to avoid any unknown issues.\n        return true\n      }\n\n      const column = columns[col]\n      if (column.validateInput) {\n        // We get the actual raw value of the new cell and\n        // validate it based on the column validateInput implementation:\n        const validationResult = column.validateInput(\n          column.getCellValue(newValue)\n        )\n        if (validationResult === true || validationResult === false) {\n          // Only return if the validation result is a valid boolean value (true or false)\n          // validationResult can also be other values, so we need to check this specifically.\n          return validationResult\n        }\n        // If it is any other value, we return it as a corrected cell:\n        return column.getCell(validationResult) as ValidatedGridCell\n      }\n      // If no validation is implemented, we accept the value:\n      return true\n    },\n    [columns]\n  )\n\n  return {\n    onCellEdited,\n    onPaste,\n    onRowAppended,\n    onDelete,\n    validateCell,\n  }\n}\n\nexport default useDataEditor\n"],"mappings":"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"}