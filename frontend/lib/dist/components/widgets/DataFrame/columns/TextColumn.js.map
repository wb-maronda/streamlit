{"version":3,"file":"TextColumn.js","names":["GridCellKind","notNullOrUndefined","isNullOrUndefined","getErrorCell","toSafeString","removeLineBreaks","TextColumn","props","parameters","columnTypeOptions","validateRegex","undefined","validate","RegExp","error","concat","cellTemplate","kind","Text","data","displayData","allowOverlay","contentAlignment","readonly","isEditable","style","isIndex","validateInput","isRequired","cellData","corrected","max_chars","length","slice","test","sortMode","getCell","validationResult","isMissingValue","getCellValue","cell","isEditableType"],"sources":["../../../../../src/components/widgets/DataFrame/columns/TextColumn.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GridCell, TextCell, GridCellKind } from \"@glideapps/glide-data-grid\"\n\nimport {\n  notNullOrUndefined,\n  isNullOrUndefined,\n} from \"@streamlit/lib/src/util/utils\"\n\nimport {\n  BaseColumn,\n  BaseColumnProps,\n  getErrorCell,\n  toSafeString,\n  removeLineBreaks,\n} from \"./utils\"\n\nexport interface TextColumnParams {\n  // The maximum number of characters the user can enter into the text input.\n  readonly max_chars?: number\n  // Regular expression that the input's value must match for the value to pass\n  readonly validate?: string\n}\n\n/**\n * A column that supports rendering & editing of text values.\n */\nfunction TextColumn(props: BaseColumnProps): BaseColumn {\n  const parameters = (props.columnTypeOptions as TextColumnParams) || {}\n\n  let validateRegex: RegExp | string | undefined = undefined\n\n  if (parameters.validate) {\n    // Prepare the validation regex:\n    try {\n      // u flag allows unicode characters\n      // s flag allows . to match newlines\n      validateRegex = new RegExp(parameters.validate, \"us\")\n    } catch (error) {\n      // Put error message in validateRegex so we can display it in the cell\n      validateRegex = `Invalid validate regex: ${parameters.validate}.\\nError: ${error}`\n    }\n  }\n\n  const cellTemplate = {\n    kind: GridCellKind.Text,\n    data: \"\",\n    displayData: \"\",\n    allowOverlay: true,\n    contentAlignment: props.contentAlignment,\n    readonly: !props.isEditable,\n    style: props.isIndex ? \"faded\" : \"normal\",\n  } as TextCell\n\n  const validateInput = (data?: any): boolean | string => {\n    if (isNullOrUndefined(data)) {\n      if (props.isRequired) {\n        return false\n      }\n      return true\n    }\n\n    let cellData = toSafeString(data)\n    // A flag to indicate whether the value has been auto-corrected.\n    // This is used to decide if we should return the corrected value or true.\n    // But we still run all other validations on the corrected value below.\n    let corrected = false\n\n    if (parameters.max_chars && cellData.length > parameters.max_chars) {\n      cellData = cellData.slice(0, parameters.max_chars)\n      corrected = true\n    }\n\n    if (\n      validateRegex instanceof RegExp &&\n      validateRegex.test(cellData) === false\n    ) {\n      return false\n    }\n\n    return corrected ? cellData : true\n  }\n\n  return {\n    ...props,\n    kind: \"text\",\n    sortMode: \"default\",\n    validateInput,\n    getCell(data?: any, validate?: boolean): GridCell {\n      if (typeof validateRegex === \"string\") {\n        // The regex is invalid, we return an error to indicate this\n        // to the developer:\n        return getErrorCell(toSafeString(data), validateRegex)\n      }\n\n      if (validate) {\n        const validationResult = validateInput(data)\n        if (validationResult === false) {\n          // The input is invalid, we return an error cell which will\n          // prevent this cell to be inserted into the table.\n          // This cell should never be actually displayed to the user.\n          // It's mostly used internally to prevent invalid input to be\n          // inserted into the table.\n          return getErrorCell(toSafeString(data), \"Invalid input.\")\n        } else if (typeof validationResult === \"string\") {\n          // Apply corrections:\n          data = validationResult\n        }\n      }\n\n      try {\n        const cellData = notNullOrUndefined(data) ? toSafeString(data) : null\n        const displayData = notNullOrUndefined(cellData)\n          ? removeLineBreaks(cellData) // Remove line breaks to show all content in the cell\n          : \"\"\n        return {\n          ...cellTemplate,\n          isMissingValue: isNullOrUndefined(cellData),\n          data: cellData,\n          displayData,\n        } as TextCell\n      } catch (error) {\n        // This should never happen, but if it does, we want to show an error\n        return getErrorCell(\n          \"Incompatible value\",\n          `The value cannot be interpreted as string. Error: ${error}`\n        )\n      }\n    },\n    getCellValue(cell: TextCell): string | null {\n      return cell.data === undefined ? null : cell.data\n    },\n  }\n}\n\nTextColumn.isEditableType = true\n\nexport default TextColumn\n"],"mappings":"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"}