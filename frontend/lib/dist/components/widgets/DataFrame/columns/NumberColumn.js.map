{"version":3,"file":"NumberColumn.js","names":["GridCellKind","Quiver","isNullOrUndefined","notNullOrUndefined","isIntegerType","countDecimals","formatNumber","getErrorCell","mergeColumnParameters","toSafeNumber","toSafeString","truncateDecimals","NumberColumn","props","arrowTypeName","getTypeName","arrowType","format","undefined","startsWith","parameters","step","min_value","columnTypeOptions","allowNegative","fixedDecimals","Number","isNaN","cellTemplate","kind","data","displayData","readonly","isEditable","allowOverlay","contentAlign","contentAlignment","style","isIndex","thousandSeparator","validateInput","cellData","isRequired","corrected","max_value","sortMode","getCell","validate","validationResult","isInteger","isSafeInteger","error","isMissingValue","copyData","getCellValue","cell","isEditableType"],"sources":["../../../../../src/components/widgets/DataFrame/columns/NumberColumn.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GridCell, GridCellKind, NumberCell } from \"@glideapps/glide-data-grid\"\n\nimport { Quiver } from \"@streamlit/lib/src/dataframes/Quiver\"\nimport {\n  isNullOrUndefined,\n  notNullOrUndefined,\n} from \"@streamlit/lib/src/util/utils\"\nimport { isIntegerType } from \"@streamlit/lib/src/components/widgets/DataFrame/isIntegerType\"\n\nimport {\n  BaseColumn,\n  BaseColumnProps,\n  countDecimals,\n  formatNumber,\n  getErrorCell,\n  mergeColumnParameters,\n  toSafeNumber,\n  toSafeString,\n  truncateDecimals,\n} from \"./utils\"\n\nexport interface NumberColumnParams {\n  // The minimum allowed value for editing. Is set to 0 for unsigned values.\n  readonly min_value?: number\n  // The maximum allowed value for editing.\n  readonly max_value?: number\n  // A formatting syntax (e.g. sprintf) to format the display value.\n  // This can be used for adding prefix or suffix, or changing the number of decimals of the display value.\n  readonly format?: string\n  // Specifies the granularity that the value must adhere.\n  // This will also influence the maximum precision. This will impact the number of decimals\n  // allowed to be entered as well as the number of decimals displayed (if format is not specified).\n  // This is set to 1 for integer types.\n  readonly step?: number\n}\n\n/**\n * A column types that supports optimized rendering and editing for numbers.\n * This supports float, integer, and unsigned integer types.\n */\nfunction NumberColumn(props: BaseColumnProps): BaseColumn {\n  const arrowTypeName = Quiver.getTypeName(props.arrowType)\n  let format = undefined\n  if (arrowTypeName === \"timedelta64[ns]\") {\n    // Use duration formatting for timedelta64[ns] type:\n    format = \"duration[ns]\"\n  } else if (arrowTypeName.startsWith(\"period[\")) {\n    // Use period formatting for period types:\n    format = arrowTypeName\n  }\n  const parameters = mergeColumnParameters(\n    // Default parameters:\n    {\n      // Set step to 1 for integer types\n      step: isIntegerType(arrowTypeName) ? 1 : undefined,\n      // if uint (unsigned int), only positive numbers are allowed\n      min_value: arrowTypeName.startsWith(\"uint\") ? 0 : undefined,\n      format,\n    } as NumberColumnParams,\n    // User parameters:\n    props.columnTypeOptions\n  ) as NumberColumnParams\n\n  const allowNegative =\n    isNullOrUndefined(parameters.min_value) || parameters.min_value < 0\n\n  const fixedDecimals =\n    notNullOrUndefined(parameters.step) && !Number.isNaN(parameters.step)\n      ? countDecimals(parameters.step)\n      : undefined\n\n  const cellTemplate = {\n    kind: GridCellKind.Number,\n    data: undefined,\n    displayData: \"\",\n    readonly: !props.isEditable,\n    allowOverlay: true,\n    contentAlign: props.contentAlignment || \"right\",\n    style: props.isIndex ? \"faded\" : \"normal\",\n    allowNegative,\n    fixedDecimals,\n    // We don't want to show any thousand separators\n    // in the cell overlay/editor:\n    thousandSeparator: \"\",\n  } as NumberCell\n\n  const validateInput = (data?: any): boolean | number => {\n    let cellData: number | null = toSafeNumber(data)\n\n    if (isNullOrUndefined(cellData)) {\n      if (props.isRequired) {\n        return false\n      }\n      return true\n    }\n\n    if (Number.isNaN(cellData)) {\n      return false\n    }\n\n    // A flag to indicate whether the value has been auto-corrected.\n    // This is used to decide if we should return the corrected value or true.\n    // But we still run all other validations on the corrected value below.\n    let corrected = false\n\n    // Apply max_value configuration option:\n    if (\n      notNullOrUndefined(parameters.max_value) &&\n      cellData > parameters.max_value\n    ) {\n      cellData = parameters.max_value\n      corrected = true\n    }\n\n    // Apply min_value configuration option:\n    if (\n      notNullOrUndefined(parameters.min_value) &&\n      cellData < parameters.min_value\n    ) {\n      // Only return false, since correcting it negatively impacts\n      // the user experience.\n      return false\n    }\n\n    // TODO(lukasmasuch): validate step size?\n    // if (notNullOrUndefined(parameters.step) && parameters.step !== 1)\n\n    return corrected ? cellData : true\n  }\n\n  return {\n    ...props,\n    kind: \"number\",\n    sortMode: \"smart\",\n    validateInput,\n    getCell(data?: any, validate?: boolean): GridCell {\n      if (validate === true) {\n        const validationResult = validateInput(data)\n        if (validationResult === false) {\n          // The input is invalid, we return an error cell which will\n          // prevent this cell to be inserted into the table.\n          // This cell should never be actually displayed to the user.\n          // It's mostly used internally to prevent invalid input to be\n          // inserted into the table.\n          return getErrorCell(toSafeString(data), \"Invalid input.\")\n        } else if (typeof validationResult === \"number\") {\n          // Apply corrections:\n          data = validationResult\n        }\n      }\n\n      let cellData: number | null = toSafeNumber(data)\n      let displayData = \"\"\n\n      if (notNullOrUndefined(cellData)) {\n        if (Number.isNaN(cellData)) {\n          return getErrorCell(\n            toSafeString(data),\n            \"The value cannot be interpreted as a number.\"\n          )\n        }\n\n        // Cut decimals:\n        if (notNullOrUndefined(fixedDecimals)) {\n          cellData = truncateDecimals(cellData, fixedDecimals)\n        }\n\n        // Check if the value is larger than the maximum supported value:\n        if (Number.isInteger(cellData) && !Number.isSafeInteger(cellData)) {\n          return getErrorCell(\n            toSafeString(data),\n            \"The value is larger than the maximum supported integer values in number columns (2^53).\"\n          )\n        }\n\n        try {\n          displayData = formatNumber(\n            cellData,\n            parameters.format,\n            fixedDecimals\n          )\n        } catch (error) {\n          return getErrorCell(\n            toSafeString(cellData),\n            notNullOrUndefined(parameters.format)\n              ? `Failed to format the number based on the provided format configuration: (${parameters.format}). Error: ${error}`\n              : `Failed to format the number. Error: ${error}`\n          )\n        }\n      }\n\n      return {\n        ...cellTemplate,\n        data: cellData,\n        displayData,\n        isMissingValue: isNullOrUndefined(cellData),\n        // We want to enforce the raw number without formatting when its copied:\n        copyData: isNullOrUndefined(cellData) ? \"\" : toSafeString(cellData),\n      } as NumberCell\n    },\n    getCellValue(cell: NumberCell): number | null {\n      return cell.data === undefined ? null : cell.data\n    },\n  }\n}\n\nNumberColumn.isEditableType = true\n\nexport default NumberColumn\n"],"mappings":"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"}