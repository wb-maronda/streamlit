{"version":3,"file":"UriUtil.js","names":["take","IS_DEV_ENV","WEBSOCKET_PORT_DEV","FINAL_SLASH_RE","INITIAL_SLASH_RE","getWindowBaseUriParts","host","window","location","hostname","port","Number","isHttps","basePath","pathname","replace","getPossibleBaseUris","baseUriParts","parts","split","possibleBaseUris","length","push","join","pop","buildWsUri","_ref","path","protocol","fullPath","makePath","concat","buildHttpUri","_ref2","subPath","href","startsWith","isValidOrigin","allowedOrigin","testOrigin","allowedUrl","testUrl","URL","pattern","splitPattern","splitHostname","every","el","index"],"sources":["../../src/util/UriUtil.ts"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport take from \"lodash/take\"\n\nimport { IS_DEV_ENV, WEBSOCKET_PORT_DEV } from \"@streamlit/lib/src/baseconsts\"\n\n/**\n * host:port tuple\n */\nexport interface BaseUriParts {\n  host: string\n  port: number\n  basePath: string\n}\n\nconst FINAL_SLASH_RE = /\\/+$/\nconst INITIAL_SLASH_RE = /^\\/+/\n\n/**\n * Return the BaseUriParts for the global window\n */\nexport function getWindowBaseUriParts(): BaseUriParts {\n  // If dev, always connect to 8501, since window.location.port is the Node\n  // server's port 3000.\n  // If changed, also change config.py\n  const host = window.location.hostname\n\n  let port\n  if (IS_DEV_ENV) {\n    port = WEBSOCKET_PORT_DEV\n  } else if (window.location.port) {\n    port = Number(window.location.port)\n  } else {\n    port = isHttps() ? 443 : 80\n  }\n\n  const basePath = window.location.pathname\n    .replace(FINAL_SLASH_RE, \"\")\n    .replace(INITIAL_SLASH_RE, \"\")\n\n  return { host, port, basePath }\n}\n\n// NOTE: In the multipage apps world, there is some ambiguity around whether a\n// path like \"foo/bar\" means\n//   * the page \"/\" at baseUrlPath \"foo/bar\", or\n//   * the page \"/bar\" at baseUrlPath \"foo\".\n// To resolve this, we just try both possibilities for now, but this leads to\n// the unfortunate consequence of the initial page load when navigating directly\n// to a non-main page of an app being slower than navigating to the main page\n// (as the first attempt at connecting to the server fails the healthcheck).\n//\n// We'll want to improve this situation in the near future, but figuring out\n// the best path forward may be tricky as I wasn't able to come up with an\n// easy solution covering every deployment scenario.\nexport function getPossibleBaseUris(): Array<BaseUriParts> {\n  const baseUriParts = getWindowBaseUriParts()\n  const { basePath } = baseUriParts\n\n  if (!basePath) {\n    return [baseUriParts]\n  }\n\n  const parts = basePath.split(\"/\")\n  const possibleBaseUris: Array<BaseUriParts> = []\n\n  while (parts.length > 0) {\n    possibleBaseUris.push({\n      ...baseUriParts,\n      basePath: parts.join(\"/\"),\n    })\n    parts.pop()\n  }\n\n  possibleBaseUris.push({\n    ...baseUriParts,\n    basePath: \"\",\n  })\n\n  return take(possibleBaseUris, 2)\n}\n\n/**\n * Create a ws:// or wss:// URI for the given path.\n */\nexport function buildWsUri(\n  { host, port, basePath }: BaseUriParts,\n  path: string\n): string {\n  const protocol = isHttps() ? \"wss\" : \"ws\"\n  const fullPath = makePath(basePath, path)\n  return `${protocol}://${host}:${port}/${fullPath}`\n}\n\n/**\n * Create an HTTP URI for the given path.\n */\nexport function buildHttpUri(\n  { host, port, basePath }: BaseUriParts,\n  path: string\n): string {\n  const protocol = isHttps() ? \"https\" : \"http\"\n  const fullPath = makePath(basePath, path)\n  return `${protocol}://${host}:${port}/${fullPath}`\n}\n\nfunction makePath(basePath: string, subPath: string): string {\n  basePath = basePath.replace(FINAL_SLASH_RE, \"\").replace(INITIAL_SLASH_RE, \"\")\n  subPath = subPath.replace(FINAL_SLASH_RE, \"\").replace(INITIAL_SLASH_RE, \"\")\n\n  if (basePath.length === 0) {\n    return subPath\n  }\n\n  return `${basePath}/${subPath}`\n}\n\n/**\n * True if we're connected to the host via HTTPS.\n */\nfunction isHttps(): boolean {\n  return window.location.href.startsWith(\"https://\")\n}\n\n/**\n * Check if the given origin follows the allowed origin pattern, which could\n * include wildcards.\n *\n * This function is used to check whether cross-origin messages received by the\n * withHostCommunication component come from an origin that we've listed as\n * trusted. If this function returns false against the origin being tested for\n * all trusted origins in our whitelist, the cross-origin message should be\n * ignored.\n */\nexport function isValidOrigin(\n  allowedOrigin: string,\n  testOrigin: string\n): boolean {\n  let allowedUrl: URL\n  let testUrl: URL\n\n  try {\n    allowedUrl = new URL(allowedOrigin)\n    testUrl = new URL(testOrigin)\n  } catch {\n    return false\n  }\n\n  // Allow localhost w/ any port for testing of host <-> guest communication\n  // using hostframe.html (facilitates manual & e2e testing)\n  if (\n    allowedUrl.protocol !== testUrl.protocol ||\n    (allowedUrl.port !== testUrl.port && testUrl.hostname !== \"localhost\")\n  ) {\n    return false\n  }\n\n  const { hostname: pattern } = allowedUrl\n  const { hostname } = testUrl\n\n  if (pattern === hostname) return true\n\n  // Web browsers will encode the wildcard character in the pattern being\n  // tested into %2A when parsing allowedOrigin into a URL, so we either have\n  // to convert it back here or test against \"%2A\" below. There's unfortunately\n  // no great way to write a unit test for this because the behavior differs\n  // between nodejs test environments and a real browser :(\n  const splitPattern = pattern.replace(/%2A/g, \"*\").split(\".\")\n  const splitHostname = hostname.split(\".\")\n\n  if (splitPattern.length !== splitHostname.length) return false\n\n  return splitPattern.every((el, index) => {\n    if (el === \"*\") {\n      return true\n    }\n\n    return el === splitHostname[index]\n  })\n}\n"],"mappings":"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"}